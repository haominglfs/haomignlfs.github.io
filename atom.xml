<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haominglfs的博客</title>
  
  <subtitle>Let&#39;s coding!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haominglfs.github.io/"/>
  <updated>2020-04-29T09:06:57.167Z</updated>
  <id>https://haominglfs.github.io/</id>
  
  <author>
    <name>haominglfs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ideaVim安装配置</title>
    <link href="https://haominglfs.github.io/2020/04/29/ideaVim%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://haominglfs.github.io/2020/04/29/ideaVim%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-29T06:03:40.000Z</published>
    <updated>2020-04-29T09:06:57.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>和安装其它插件一样，直接在插件市场搜索ideaVim安装即可。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h4><p>ideaViim键与idea快捷键有冲突，可以在Editor Vim Emulation设置，我的快捷键设置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200429143559.png" alt></p><a id="more"></a><h3 id="ideavim配置文件讲解"><a href="#ideavim配置文件讲解" class="headerlink" title=".ideavim配置文件讲解"></a>.ideavim配置文件讲解</h3><h5 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h5><p>开发过idea插件的人都知道，在idea中，任何目录选项上的点击操作，工具栏上的按钮都会被映射为一个<code>action</code>。即点击对应的按钮或者选项，执行相应的<code>action</code>。理解很简单，这就是MVC的思想，比如springmvc， 一个访问路径映射为一个控制器中的方法这样子。</p><p>明白<code>action</code>映射这一点很重要。因为ideavim的插件支持使用vim命令执行对应的<code>action</code>。所以，这个设计逻辑就打通了vim和idea的交互，使得我们可以在vim中完成所有和idea相关的操作。</p><h5 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h5><p>vim的定位是文本编辑。所以在idea中一般情况下vim快捷键和命令生效的基本条件就是当前窗口焦点在编辑区。这是最基础的条件，如果你当前的快键键在<code>Project</code>或者<code>Run</code>这些侧边栏中，按vim的命令肯定是不会生效的。</p><p>明白了基本条件，那我们要做的第一件事也是最重要的事情就是在idea中，如何快速的将焦点回到的编辑区。答案是：Esc</p><p>这应该是使用vim的人最能接受的快捷键了。所以，到这里基本的操作思路就很明确，当前的焦点要么在编辑区外，要么在编辑区内。而返回编辑区的操作很简单，就是<code>Esc</code>。当焦点在编辑区的时候，就可以随心所欲的使用vim的指令和快捷键了。</p><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>有了idea基本的了解之后，我们就可以着手配置自己的vim了。ideavim插件的配置通常是<code>~/.ideavimrc</code>，所以将自己的配置脚本写在对应的文件中即可。当然如果你已经有了自己的vim配置文件在<code>~/.vimrc</code>下，那只需要在ideavim的配置文件中添加一行命令即可全部读取映射过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.vimrc</span><br></pre></td></tr></table></figure><p>在~目录下，创建.ideavimrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"设置高亮搜索</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">"重命名文件</span><br><span class="line">nnoremap &lt;Space&gt;rf :action RenameFile&lt;CR&gt;</span><br><span class="line">"跳到指定类</span><br><span class="line">nnoremap &lt;Space&gt;gc :action GotoClass&lt;CR&gt;</span><br><span class="line">"查找使用</span><br><span class="line">nnoremap &lt;Space&gt;fu :action FindUsages&lt;CR&gt;</span><br><span class="line">"跳转到方法的声明</span><br><span class="line">nnoremap &lt;Space&gt;gs :action GotoSuperMethod&lt;CR&gt;</span><br></pre></td></tr></table></figure><h5 id="在vim中执行idea的action"><a href="#在vim中执行idea的action" class="headerlink" title="在vim中执行idea的action"></a>在vim中执行idea的action</h5><p>为了执行idea中的<code>action</code>，ideavim有两个额外的命令来支持这一操作。</p><ul><li><code>:actionlist [pattern]</code></li><li><code>:action {actionName}</code></li></ul><p>第一个命令actionlist是帮助查看idea中有哪些命令。第二个命令是执行对应的<code>action</code>这样子。有了这两个命令的帮助我们就可以在ideavim的配置文件中使用map命令来映射idea的<code>action</code>到vim的快捷键中。</p><h2 id="Vim-中的-remap，noremap"><a href="#Vim-中的-remap，noremap" class="headerlink" title="Vim 中的 remap，noremap"></a>Vim 中的 remap，noremap</h2><p><code>remap</code>是一个使映射以递归方式工作的<strong>选项</strong> 。</p><p><code>:map</code>和<code>:noremap</code>是各种映射命令的<strong>递归</strong>和<strong>非递归</strong>版本。这意味着，如果你这样做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:map j gg</span><br><span class="line">:map Q j</span><br><span class="line">:noremap W j</span><br></pre></td></tr></table></figure><p><code>j</code>将映射到<code>gg</code> 。 <code>Q</code> <em>也</em>将映射到<code>gg</code> ，因为<code>j</code>将被扩展用于递归映射。 <code>W</code>将被映射到<code>j</code> （而不是<code>gg</code> ），因为<code>j</code>不会针对非递归映射进行扩展。</p><p>现在请记住，Vim 是一个<strong>模态编辑器</strong> 。它具有<strong>普通</strong>模式， <strong>可视</strong>模式和其他模式。</p><p>对于这些映射集中的每一个，都有一个<a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1" target="_blank" rel="noopener">映射</a>#Creating_keymaps)可以在正常，可视，选择和操作员模式下工作（ <code>:map</code>和<code>:noremap</code> ），一个在普通模式下工作（ <code>:nmap</code>和<code>:nnoremap</code> ），一个在可视模式下（ <code>:vmap</code>和<code>:vnoremap</code> ）等等。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programtip.com/zh/art-127704" target="_blank" rel="noopener">https://programtip.com/zh/art-127704</a></p><p><a href="https://blog.csdn.net/qq_40250122/article/details/102054921" target="_blank" rel="noopener">https://blog.csdn.net/qq_40250122/article/details/102054921</a></p><p><a href="https://my.oschina.net/funcy/blog/1832719" target="_blank" rel="noopener">https://my.oschina.net/funcy/blog/1832719</a></p><p><a href="https://blog.csdn.net/CoderBruis/article/details/94735816" target="_blank" rel="noopener">https://blog.csdn.net/CoderBruis/article/details/94735816</a></p><p><a href="https://routinepanic.com/questions/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping" target="_blank" rel="noopener">https://routinepanic.com/questions/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;和安装其它插件一样，直接在插件市场搜索ideaVim安装即可。&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;h4 id=&quot;快捷键设置&quot;&gt;&lt;a href=&quot;#快捷键设置&quot; class=&quot;headerlink&quot; title=&quot;快捷键设置&quot;&gt;&lt;/a&gt;快捷键设置&lt;/h4&gt;&lt;p&gt;ideaViim键与idea快捷键有冲突，可以在Editor Vim Emulation设置，我的快捷键设置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/haominglfs/images/20200429143559.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="idea" scheme="https://haominglfs.github.io/categories/idea/"/>
    
    
      <category term="idea vim" scheme="https://haominglfs.github.io/tags/idea-vim/"/>
    
  </entry>
  
  <entry>
    <title>ELK安装配置</title>
    <link href="https://haominglfs.github.io/2020/04/16/ELK%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://haominglfs.github.io/2020/04/16/ELK%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-16T13:54:25.000Z</published>
    <updated>2020-04-21T13:58:00.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ELK常见架构"><a href="#ELK常见架构" class="headerlink" title="ELK常见架构"></a>ELK常见架构</h3><h4 id="Elasticsearch-Logstash-Kibana"><a href="#Elasticsearch-Logstash-Kibana" class="headerlink" title="Elasticsearch + Logstash + Kibana"></a>Elasticsearch + Logstash + Kibana</h4><p>这是一种最简单的架构。这种架构，通过logstash收集日志，Elasticsearch分析日志，然后在Kibana(web界面)中展示。这种架构虽然是官网介绍里的方式，但是往往在生产中很少使用。</p><h4 id="Elasticsearch-Logstash-filebeat-Kibana"><a href="#Elasticsearch-Logstash-filebeat-Kibana" class="headerlink" title="Elasticsearch + Logstash + filebeat + Kibana"></a>Elasticsearch + Logstash + filebeat + Kibana</h4><p>与上一种架构相比，这种架构增加了一个filebeat模块。filebeat是一个轻量的日志收集代理，用来部署在客户端，优势是消耗非常少的资源(较logstash)， 所以生产中，往往会采取这种架构方式，但是这种架构有一个缺点，当logstash出现故障， 会造成日志的丢失。</p><h4 id="Elasticsearch-Logstash-filebeat-redis-也可以是其他中间件，比如kafka-Kibana"><a href="#Elasticsearch-Logstash-filebeat-redis-也可以是其他中间件，比如kafka-Kibana" class="headerlink" title="Elasticsearch + Logstash + filebeat + redis(也可以是其他中间件，比如kafka) + Kibana"></a>Elasticsearch + Logstash + filebeat + redis(也可以是其他中间件，比如kafka) + Kibana</h4><p>这种架构是上面那个架构的完善版，通过增加中间件，来避免数据的丢失。当Logstash出现故障，日志还是存在中间件中，当Logstash再次启动，则会读取中间件中积压的日志。</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200416220019.png" alt></p><a id="more"></a><h3 id="filebeat安装部署"><a href="#filebeat安装部署" class="headerlink" title="filebeat安装部署"></a>filebeat安装部署</h3><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200420164241.png" alt></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Filebeat是一个日志文件托运工具，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh、redis中存放。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>filebeat由2个主要组件构成：prospector和harvesters。这两类组件一起协同完成Filebeat的工作，从指定文件中把数据读取出来，然后发送事件数据到配置的output中。</p><p>harvesters：主要负责进行单个文件的内容收集；在运行过程中，每一个Harvester会对一个文件逐行进行内容读取，并且把读写到的内容发送到配置的output中。</p><p>Prospector负责管理Harvsters，并且找到所有需要进行读取的数据源。如果input type配置的是log类，Prospector将会去配置度路径下查找所有能匹配上的文件，然后为每一个文件创建一个Harvster。每个Prospector都运行在自己的Go routine里。</p><p>当你开启filebeat程序的时候，它会启动一个或多个探测器（prospectors）去检测你指定的日志目录或文件，对于探测器找出的每一个日志文件，filebeat启动收割进程（harvester），每一个收割进程读取一个日志文件的新内容，并发送这些新的日志数据到处理程序（spooler），处理程序会集合这些事件，最后filebeat会发送集合的数据到你指定的地点。    </p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.2.2-x86_64.rpm</span><br><span class="line">sudo rpm -vi filebeat-5.2.2-x86_64.rpm</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">=========================== Filebeat prospectors =============================</span></span><br><span class="line"><span class="meta">#</span><span class="bash">filebeat.prospectors模块用来指定日志文件的来源。</span></span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log #input_type 指定日志类型，在这里是log， 应该也可以是json</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:  #paths指定日志文件路径。</span><br><span class="line">    - /root/myapp/tomcat/tomcat8/logs/*.log</span><br><span class="line"><span class="meta">#</span><span class="bash">================================ redis =====================================</span></span><br><span class="line">output.redis:</span><br><span class="line">    hosts: ["152.136.233.203:6379"]</span><br><span class="line">    password: "redis"</span><br><span class="line">    datatype: list</span><br><span class="line">    key: "tomcat-log"</span><br><span class="line">    db: 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">document_type：这个字段是用来给日志打标记的。 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">fields: 也是打标记，主要为了后面日志分析查找的方便，存储的时候也会根据fields分类存储，相同fields的数据存在同一个redis key中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">fields_under_root: 如果该选项设置为<span class="literal">true</span>， 则该fields会存储在top-level中。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tail_files: 这个选项如果设置为<span class="literal">true</span>，则读取日志文件的新内容，而忽略原有的内容，一般要设置为<span class="literal">true</span></span></span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start filebeat</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>filebeat怎么设置从头开始读取</p><ol><li><p>找到registry文件的位置，如果没有单独配置那么文件路径为<code>/var/lib/filebeat/registry</code>，不在也没关心，可以直接find命令查找</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name registry</span><br></pre></td></tr></table></figure></li><li><p>关闭filebeat –&gt; 删掉registry文件 –&gt; 启动filebeat</p></li></ol></li><li><p>Filebeat插件启动失败，不能直接查找报错原因</p><p>老是在filebeat启动的这一步骤上出错，但是由于filebeat是由systemd启动的，因此原因也经常查不清楚，因此并不能直观的查出错误在哪里，所以今天教给大家两个寻找错误的根源的方法:</p><p>直接使用filebeat的启动方法，而不使用systemctl start filebeat来启动。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/filebeat/bin/filebeat -c /etc/filebeat/filebeat.yml -path.home /usr/share/filebeat -path.config /etc/filebeat -path.data /var/lib/filebeat -path.logs /var/log/filebeat</span><br></pre></td></tr></table></figure></li></ol><h3 id="logstash-安装配置"><a href="#logstash-安装配置" class="headerlink" title="logstash 安装配置"></a>logstash 安装配置</h3><h4 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-5.2.2.tar.gz</span><br><span class="line">tar xf logstash-5.2.0.tar.gz -C /opt/app/</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/ls-data  #创建/data/ls-data目录，用于logstash数据的存放</span><br><span class="line">chown -R logstash:logstash /data/ls-data #修改该目录的拥有者为logstash</span><br><span class="line">mkdir -p /log/ls-log #创建/data/ls-log目录，用于logstash日志的存放</span><br><span class="line">chown -R logstash:logstash /log/ls-log #修改该目录的拥有者为logstash</span><br></pre></td></tr></table></figure><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /config/logstash/config.d</span><br><span class="line">vim logstash.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; "localhost"</span><br><span class="line">    port =&gt; "6379"</span><br><span class="line">    db =&gt; "1"</span><br><span class="line">    data_type =&gt; "list"</span><br><span class="line">    key =&gt; "tomcat-log"</span><br><span class="line">    codec =&gt; plain &#123;</span><br><span class="line">          charset =&gt; "UTF-8"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123; </span><br><span class="line">  hosts =&gt; ["localhost:9200"] </span><br><span class="line">  index =&gt; "tomcat-log"</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input是redis， 需要指定redis的host 和port以及db，还要指明数据的类型，list表示这是一个redis的list对象。key指明redis中的key名称。</p><p>output 是elasticsearch， hosts指明elasticsearch的ip和端口，index指明这个日志存在elasticsearch中的索引名称。</p><h4 id="修改配置文件-opt-logstash-5-2-2-config-logstash-yml"><a href="#修改配置文件-opt-logstash-5-2-2-config-logstash-yml" class="headerlink" title="修改配置文件(/opt/logstash-5.2.2/config/logstash.yml)"></a>修改配置文件(/opt/logstash-5.2.2/config/logstash.yml)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置数据的存储路径为/data/ls-data</span></span><br><span class="line">path.data: /data/ls-data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置管道配置文件路径为/etc/logstash/conf.d</span></span><br><span class="line">path.config: /etc/logstash/conf.d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置日志文件的存储路径为/<span class="built_in">log</span>/ls-log</span></span><br><span class="line">path.logs: /log/ls-log</span><br></pre></td></tr></table></figure><h5 id="测试logstash"><a href="#测试logstash" class="headerlink" title="测试logstash"></a>测试logstash</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./logstash -f /config/logstash/config.d/logstash.conf --config.test_and_exit</span><br><span class="line"><span class="meta">#</span><span class="bash">--config.test_and_exit表示，检查测试创建的logstash.conf配置文件，是否有问题，如果没有问题，执行之后，显示Configuration OK 证明配置成功！</span></span><br></pre></td></tr></table></figure><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf &amp;</span><br></pre></td></tr></table></figure><h3 id="elasticsearch安装"><a href="#elasticsearch安装" class="headerlink" title="elasticsearch安装"></a>elasticsearch安装</h3><h4 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.tar.gz</span><br><span class="line">tar -xvf elasticsearch-5.2.2.tar.gz -C  /opt/app/</span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/es-data #创建/data/es-data目录，用于elasticsearch数据的存放</span><br><span class="line">chown -R elasticsearch:elasticsearch /data/es-data  #修改该目录的拥有者为elasticsearch</span><br><span class="line">mkdir -p /log/es-log   #创建/data/es-log目录，用于elasticsearch日志的存放</span><br><span class="line">chown -R elasticsearch:elasticsearch /log/es-log #修改该目录的拥有者为elasticsearch</span><br></pre></td></tr></table></figure><h4 id="修改配置文件-opt-elasticsearch-5-2-2-config-elasticsearch-yml"><a href="#修改配置文件-opt-elasticsearch-5-2-2-config-elasticsearch-yml" class="headerlink" title="修改配置文件 (/opt/elasticsearch-5.2.2/config/elasticsearch.yml)"></a>修改配置文件 (/opt/elasticsearch-5.2.2/config/elasticsearch.yml)</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置data存放的路径为/data/es-data</span></span><br><span class="line"><span class="string">path.data:</span> <span class="string">/data/es-data</span></span><br><span class="line"><span class="comment">#设置logs日志的路径为/log/es-log</span></span><br><span class="line"><span class="string">path.logs:</span> <span class="string">/log/es-log</span></span><br><span class="line"><span class="comment">#设置内存不使用交换分区</span></span><br><span class="line"><span class="string">bootstrap.memory_lock:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#配置了bootstrap.memory_lock为true时反而会引发9200不会被监听，原因不明</span></span><br><span class="line"><span class="comment">#设置允许所有ip可以连接该elasticsearch</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">#开启监听的端口为9200</span></span><br><span class="line"><span class="string">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#增加新的参数，为了让elasticsearch-head插件可以访问es (5.x版本，如果没有可以自己手动加)</span></span><br><span class="line"><span class="string">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h4 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h4><p><strong><em>注意，如果你使用root用户启动elasticsearch，就会报错，启动失败，这是因为elasticsearch不允许用root用户启动。可以创建一个用户，用来启动elasticsearch</em></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd elasticsearch  #添加组</span><br><span class="line">useradd -g elasticsearch elasticsearch #添加用户</span><br><span class="line">chown -R elasticsearch:elasticsearch  /opt/app/elasticsearch-5.2.2/ #设置权限</span><br><span class="line">/opt/app/elasticsearch-5.2.2/bin/elasticsearch -d  #启动，后台运行</span><br></pre></td></tr></table></figure><h3 id="kibana安装配置"><a href="#kibana安装配置" class="headerlink" title="kibana安装配置"></a>kibana安装配置</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-5.2.2-linux-x86_64.tar.gz</span><br><span class="line">tar -xzf kibana-5.2.2-linux-x86_64.tar.gz -C /opt/app/</span><br></pre></td></tr></table></figure><h4 id="配置-opt-app-kibana-5-2-2-linux-x86-64-config-kibana-yml"><a href="#配置-opt-app-kibana-5-2-2-linux-x86-64-config-kibana-yml" class="headerlink" title="配置(/opt/app/kibana-5.2.2-linux-x86_64/config/kibana.yml)"></a>配置(/opt/app/kibana-5.2.2-linux-x86_64/config/kibana.yml)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.host: "0.0.0.0" #指明服务运行的地址</span><br><span class="line">elasticsearch.url: "http://localhost:9200" #指明elasticsearch运行的地址和端口</span><br><span class="line">kibana.index: ".kibana"  #指明kibana使用的索引，这个是自定义的。</span><br></pre></td></tr></table></figure><h4 id="启动-3"><a href="#启动-3" class="headerlink" title="启动"></a>启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/kibana-5.2.2-linux-x86_64/bin/kibana</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/e7362ccfe7e3" target="_blank" rel="noopener">https://www.jianshu.com/p/e7362ccfe7e3</a></p><p><a href="http://www.justdojava.com/2019/08/11/elk-install/" target="_blank" rel="noopener">http://www.justdojava.com/2019/08/11/elk-install/</a></p><p><a href="https://blog.51cto.com/liqingbiao/2177873" target="_blank" rel="noopener">https://blog.51cto.com/liqingbiao/2177873</a></p><p><a href="https://www.cnblogs.com/FengGeBlog/p/10644170.html" target="_blank" rel="noopener">https://www.cnblogs.com/FengGeBlog/p/10644170.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ELK常见架构&quot;&gt;&lt;a href=&quot;#ELK常见架构&quot; class=&quot;headerlink&quot; title=&quot;ELK常见架构&quot;&gt;&lt;/a&gt;ELK常见架构&lt;/h3&gt;&lt;h4 id=&quot;Elasticsearch-Logstash-Kibana&quot;&gt;&lt;a href=&quot;#Elasticsearch-Logstash-Kibana&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch + Logstash + Kibana&quot;&gt;&lt;/a&gt;Elasticsearch + Logstash + Kibana&lt;/h4&gt;&lt;p&gt;这是一种最简单的架构。这种架构，通过logstash收集日志，Elasticsearch分析日志，然后在Kibana(web界面)中展示。这种架构虽然是官网介绍里的方式，但是往往在生产中很少使用。&lt;/p&gt;
&lt;h4 id=&quot;Elasticsearch-Logstash-filebeat-Kibana&quot;&gt;&lt;a href=&quot;#Elasticsearch-Logstash-filebeat-Kibana&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch + Logstash + filebeat + Kibana&quot;&gt;&lt;/a&gt;Elasticsearch + Logstash + filebeat + Kibana&lt;/h4&gt;&lt;p&gt;与上一种架构相比，这种架构增加了一个filebeat模块。filebeat是一个轻量的日志收集代理，用来部署在客户端，优势是消耗非常少的资源(较logstash)， 所以生产中，往往会采取这种架构方式，但是这种架构有一个缺点，当logstash出现故障， 会造成日志的丢失。&lt;/p&gt;
&lt;h4 id=&quot;Elasticsearch-Logstash-filebeat-redis-也可以是其他中间件，比如kafka-Kibana&quot;&gt;&lt;a href=&quot;#Elasticsearch-Logstash-filebeat-redis-也可以是其他中间件，比如kafka-Kibana&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch + Logstash + filebeat + redis(也可以是其他中间件，比如kafka) + Kibana&quot;&gt;&lt;/a&gt;Elasticsearch + Logstash + filebeat + redis(也可以是其他中间件，比如kafka) + Kibana&lt;/h4&gt;&lt;p&gt;这种架构是上面那个架构的完善版，通过增加中间件，来避免数据的丢失。当Logstash出现故障，日志还是存在中间件中，当Logstash再次启动，则会读取中间件中积压的日志。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/haominglfs/images/20200416220019.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日志" scheme="https://haominglfs.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Elasticsearch Logstash Kibana" scheme="https://haominglfs.github.io/tags/Elasticsearch-Logstash-Kibana/"/>
    
  </entry>
  
  <entry>
    <title>类图</title>
    <link href="https://haominglfs.github.io/2020/04/06/%E7%B1%BB%E5%9B%BE/"/>
    <id>https://haominglfs.github.io/2020/04/06/%E7%B1%BB%E5%9B%BE/</id>
    <published>2020-04-06T03:25:22.000Z</published>
    <updated>2020-04-16T13:54:35.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合类图"><a href="#集合类图" class="headerlink" title="集合类图"></a>集合类图</h3><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200406141848.png" alt></p><a id="more"></a><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200406150924.png" alt></p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200415194212.png" alt="InputStream"></p><h5 id="FilterInputStream剖析"><a href="#FilterInputStream剖析" class="headerlink" title="FilterInputStream剖析"></a>FilterInputStream剖析</h5><p>这个类的特殊之处，就是包含了一个InputStream，使得可以在这个InputStream基础上进行多种封装，从而达到装饰的目的。</p><p>装饰者模式，顾名思义，是对原有类进行了一定的装饰，装饰后的类必须和原有的类拥有相同的方法，当然，可以在原有类的基础上进行扩展。</p><p>这里的装饰者模式通过包含一个原有的Inputstream对象，并且将InputStream原有的方法或直接暴露，或进行装饰后暴露，又或者添加了新的特性，如DataInputStream中的readInt()，BufferedInputStream中的缓存功能。</p><p>为什么InputStream选择装饰者模式，而非直接继承的方法来扩展，这就是装饰者模式VS继承。如果单纯的使用继承，就会造成类的“爆炸”式增长。</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200415204429.png" alt></p><p>直接使用继承，可以实现“目的”和“方法”，但是每一种来源的输入流，都需要改善流读取方法，因此在使用继承时，每一个InputStream的子类都需要DataInputStream，BufferedInputStream这几个类提供的“装饰作用”的功能，因此需要的类的数目就是A*B的数目。</p><p>而直接使用装饰者模式，将InputStream的几个直接子类进一步抽象，在此基础上提供装饰作用，所需要的类的数目是A+B。使用装饰者模式使得java类的更有层次性，类的数目得到充分控制。这就是装饰者模式相比于继承的优势。</p><h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200416173453.png" alt></p><h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200416174538.png" alt></p><h4 id="字符输入流-1"><a href="#字符输入流-1" class="headerlink" title="字符输入流"></a>字符输入流</h4><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200416190044.png" alt></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/zhao123h/java/article/details/52826682" target="_blank" rel="noopener">https://blog.csdn.net/zhao123h/java/article/details/52826682</a></p><p><a href="https://blog.csdn.net/zhoupenglei/article/details/46312405" target="_blank" rel="noopener">https://blog.csdn.net/zhoupenglei/article/details/46312405</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;集合类图&quot;&gt;&lt;a href=&quot;#集合类图&quot; class=&quot;headerlink&quot; title=&quot;集合类图&quot;&gt;&lt;/a&gt;集合类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/haominglfs/images/20200406141848.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://haominglfs.github.io/categories/java/"/>
    
    
      <category term="类图 java" scheme="https://haominglfs.github.io/tags/%E7%B1%BB%E5%9B%BE-java/"/>
    
  </entry>
  
  <entry>
    <title>jvm性能监控与调优</title>
    <link href="https://haominglfs.github.io/2020/03/23/jvm%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <id>https://haominglfs.github.io/2020/03/23/jvm%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</id>
    <published>2020-03-23T15:10:24.000Z</published>
    <updated>2020-04-06T03:20:08.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jvm参数类型"><a href="#jvm参数类型" class="headerlink" title="jvm参数类型"></a>jvm参数类型</h3><a id="more"></a><ul><li><p>标准参数(jvm各个版本基本不变)</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-help  </span><br><span class="line">-server </span><br><span class="line">-client </span><br><span class="line">-version </span><br><span class="line">-cp </span><br><span class="line">-classpath</span><br></pre></td></tr></table></figure></li></ul></li><li><p>X参数（非标准化参数，变化比较小）</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xint 解释执行</span><br><span class="line">-Xcomp 第一次使用就编译成本地代码</span><br><span class="line">-Xmixed 混合模式，JVM自己来决定是否编译成本地代码</span><br></pre></td></tr></table></figure></li></ul></li><li><p>XX参数（用的比较多，主要用来JVM调优和debug）</p><ul><li><p>Boolean类型</p><p>格式：-XX:[+-]<name>表示启用或者禁用name属性</name></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure></li><li><p>非Boolean类型</p><p>格式：-XX:<name>=<value> 表示name属性的值是value</value></name></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=500</span><br><span class="line">XX:GCTimeRatio=19</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-Xms -Xmx 属于XX参数</span></span><br><span class="line">-Xms 等价于 -XX:InitialHeapSize</span><br><span class="line">-Xmx 等价于 -XX:MaxHeapSize</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="查看jvm运行时参数"><a href="#查看jvm运行时参数" class="headerlink" title="查看jvm运行时参数"></a>查看jvm运行时参数</h3><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial 查看初始值</span><br><span class="line">-XX:+PrintFlagsFinal  查看最终值</span><br><span class="line">-XX:+UnlockExperimentalVMOptions 解锁实验参数</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions 解锁诊断参数</span><br><span class="line">-XX:+PrintCommandLineFlags  打印命令行参数</span><br></pre></td></tr></table></figure></li><li><p><code>-XX:+PrintFlagsFinal</code>  </p><p><code>java  -XX:+PrintFlagsFinal -version</code></p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200323234316.png" alt></p><p>=表示默认值</p><p>:=被用户或者jvm修改后的值</p></li><li><p>jinfo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 55208  打印被修改过的jvm参数值</span><br><span class="line">jinfo -flag &lt;name&gt; 55208  打印对应name的参数值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200323234724.png" alt></p></li></ul><h3 id="查看jvm统计信息"><a href="#查看jvm统计信息" class="headerlink" title="查看jvm统计信息"></a>查看jvm统计信息</h3><ul><li><p>jstat</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200323235354.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options: </span><br><span class="line"> -class 类装载</span><br><span class="line"> -compiler JIT编译信息</span><br><span class="line"> -gc 垃圾回收信息</span><br></pre></td></tr></table></figure><ul><li><p>类装载</p></li><li><p>垃圾收集</p><p>S0C S1C S0U S1U : S0与S1的总量与使用量</p><p>EC EU ：Eden区总量与使用量</p><p>OC OU：Old区的总量与使用量</p><p>MC MU：Metaspace 区总量与使用量</p><p>CCSC CCSU：压缩类空间总量与使用量</p><p>YGC YGCT ：YongGC的次数与时间</p><p>FGC FGCT：FullGC的次数与时间</p><p>GCT：总的GC时间</p></li><li><p>JIT编译</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200324001144.png" alt></p></li></ul></li></ul><h3 id="导出内存映像文件"><a href="#导出内存映像文件" class="headerlink" title="导出内存映像文件"></a>导出内存映像文件</h3><ul><li><p>内存溢出自动导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用jmap命令手动导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heap.hprof &lt;虚拟机id&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;jvm参数类型&quot;&gt;&lt;a href=&quot;#jvm参数类型&quot; class=&quot;headerlink&quot; title=&quot;jvm参数类型&quot;&gt;&lt;/a&gt;jvm参数类型&lt;/h3&gt;
    
    </summary>
    
    
      <category term="jvm" scheme="https://haominglfs.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://haominglfs.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用总结</title>
    <link href="https://haominglfs.github.io/2020/02/26/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://haominglfs.github.io/2020/02/26/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-26T08:57:42.000Z</published>
    <updated>2020-04-06T03:21:21.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><ol><li><p>添加一条域名解析记录</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200226170106.png" alt></p><a id="more"></a></li><li><p>在hexo的source文件夹中添加CNAME文件，内容为自己的域名</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200226170452.png" alt></p></li></ol><h3 id="修改新建文章模版"><a href="#修改新建文章模版" class="headerlink" title="修改新建文章模版"></a>修改新建文章模版</h3><p>模版路径为hexo/scaffolds/post.md</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自定义域名&quot;&gt;&lt;a href=&quot;#自定义域名&quot; class=&quot;headerlink&quot; title=&quot;自定义域名&quot;&gt;&lt;/a&gt;自定义域名&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加一条域名解析记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/haominglfs/images/20200226170106.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://haominglfs.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://haominglfs.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习</title>
    <link href="https://haominglfs.github.io/2020/02/22/RabbitMQ%E5%AD%A6%E4%B9%A0/"/>
    <id>https://haominglfs.github.io/2020/02/22/RabbitMQ%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-22T15:03:56.000Z</published>
    <updated>2020-02-26T08:38:16.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装并启动"><a href="#安装并启动" class="headerlink" title="安装并启动"></a>安装并启动</h3><ol><li><p>配置yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[rabbitmq-erlang]</span><br><span class="line">name=rabbitmq-erlang</span><br><span class="line">baseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>安装  <code>yum install -y rabbitmq-server</code></p></li><li><p>启动 <code>rabbitmq-server start &amp;</code></p></li><li><p>安装管控台插件 <code>rabbitmq-plugins enable rabbitmq_management</code></p></li></ol><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><ol><li><p>登录</p><p>浏览器输入<code>http://ip:15672/</code>  用户名<code>guest</code>  密码<code>guest</code></p></li></ol><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ol><li>关闭应用  <code>rabbitmqctl stop_app</code></li><li>启动应用 <code>rabbitmqctl start_app</code></li><li>节点状态 <code>rabbitmqctl status</code></li><li>添加用户 <code>rabbitmqctl add username password</code></li><li>列出所有用户 <code>rabbitmqctl list_users</code></li><li>删除用户 <code>rabbitmqctl delete_user username</code></li><li>修改密码 <code>rabbitmqctl change_password username newpassword</code></li><li>列出用户权限<code>rabbitmqctl list_user_permissions username</code></li><li>清除用户权限 <code>rabbitmqctl clear_permissions -p vhostpath username</code></li><li>设置用户权限 <code>rabbitmqctl set_permissions -p vhostpath username &quot;.*&quot;&quot;.*&quot;&quot;.*&quot;</code></li><li>创建虚拟主机<code>rabbitmqctl add_vhost vhostpath</code></li><li>列出所有虚拟主机  <code>rabbitmqctl list_vhost</code></li><li>列出虚拟主机上所有权限  <code>rabbitmqctl list_permissions -p vhostpath</code></li><li>删除虚拟主机 <code>rabbitmqctl delete_vhost vhostpath</code></li><li>查看所有队列信息 <code>rabbitmqctl list_queues</code></li><li>清除队列中的消息 <code>rabbitmqctl -p vhostpath purge_queue blue</code></li><li>移除所有数据（要在rabbitmqctl stop_app之后使用） <code>rabbitmqctl reset</code></li><li>组成集群命令<code>rabbitmqctl join_cluster &lt;clusternode&gt; [--ram]</code></li><li>查看集群状态<code>rabbitmqctl cluster_status</code></li><li>修改集群节点的存储形式<code>rabbitmqctl change_cluster_node_type disc|ram</code></li><li>摘除节点<code>rabbitmqctl forget_cluster_node [offline]</code></li><li>修改节点名称<code>rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2]</code></li></ol><h3 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq.quickstart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: haoming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/2/23 4:03 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.233.203"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//2.通过连接工厂创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.通过connection创建一个channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//4.通过channel发送数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">"hello RabbitMQ!"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,<span class="string">"test001"</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">          <span class="comment">//如果未指定exchange，默认使用(AMQP default) exchange,这个exchange会根据routerKey找到同名队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.关闭相关的连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq.quickstart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: haoming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/2/23 4:04 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"152.136.233.203"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//2.通过连接工厂创建连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3.通过connection创建一个channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//4.声明（创建）一个队列</span></span><br><span class="line">        String queueName = <span class="string">"test001"</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//5.创建消费者</span></span><br><span class="line">        QueueingConsumer queueingConsumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">//6.设置channel</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,queueingConsumer);</span><br><span class="line">        <span class="comment">//7.获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();</span><br><span class="line">            String msg = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">"msg="</span>+msg);</span><br><span class="line">            <span class="comment">//Envelope envelope = delivery.getEnvelope();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>接收消息，并根据路由键转发消息到绑定的队列。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>Name 交换机名称</li><li>Type 交换机类型 direct topic fanout headers（以下图片参考<a href="https://www.cnblogs.com/stefan-liu/p/5315809.html）" target="_blank" rel="noopener">https://www.cnblogs.com/stefan-liu/p/5315809.html）</a><ul><li>direct（使用比较多）<ul><li>所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue。</li><li>Direct模式可以使用RabbitMQ自带的Exchange:default Exchange,所以不需要将Exchange进行任何绑定（binding）操作，消息传递时，RouterKey必须完全匹配才能完全接收，否则该消息会被抛弃。</li><li><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200223204301.png" alt></li></ul></li><li>Topic <ul><li>所有发送到Topic Exchange的消息被转发到所有关心RouterKey中指定Topic的Queue上。</li><li>Exchange将RouteKey和某Topic进行模糊匹配，此时队列需要绑定一个Topic。</li><li><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200223204659.png" style="zoom:50%;"></li></ul></li><li>fanout<ul><li>不处理路由键，只需要简单的将队列绑定到交换机上。</li><li>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。</li><li>转发消息是最快的。</li><li><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200223210410.png" alt></li></ul></li></ul></li><li>Durability 是否需要持久化，true未持久化。</li><li>Auto Delete 当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange。</li><li>Internal 当前Exchange是否用于RabbitMQ内部使用，默认为false。</li><li>Arguments 扩展参数，用于扩展AMQP自制定化使用。</li></ul><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><ul><li><p>符号 “#” 匹配一个或多个词</p><p>“log.#” 能够匹配到“log.info.oa”</p></li><li><p>符号 “*” 匹配不多不少一个词</p><p>“log.*” 只会匹配到 “log.erro”</p></li></ul><h3 id="binding"><a href="#binding" class="headerlink" title="binding"></a>binding</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>Exchange 和 Exchang、Queue之间的连接关系。</p><p>Binding中可以包含RoutingKey或者参数。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>存储消息数据</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul><li>Durability:是否持久化，Durable:是；Transient:否。</li><li>Auto delete:yes:表示当最后一个监听移除之后，该Queue会自动被删除。</li></ul><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>服务器和应用程序之间传送的数据。</p><p>本质上就是一段数据，由Properties和Payload(Body)组成。</p><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul><li><p>Delivery mode  送达模式  ：持久化非持久化</p></li><li><p>Headers 自定义属性</p></li><li><p>其他属性：</p><ul><li>content_type </li><li>content_encoding </li><li>priority  优先级</li><li>correlation_id   消息唯一id(消息幂等)</li><li>reply_to</li><li>expiration 消息到期时间</li><li>message_id 消息的id</li><li>timestamp</li><li>type</li><li>user_id</li><li>app_id</li><li>cluster_id</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">headers.put(<span class="string">"my1"</span>, <span class="string">"111"</span>);</span><br><span class="line">headers.put(<span class="string">"my2"</span>, <span class="string">"222"</span>);</span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">  .deliveryMode(<span class="number">2</span>)</span><br><span class="line">  .contentEncoding(<span class="string">"UTF-8"</span>)</span><br><span class="line">  .expiration(<span class="string">"10000"</span>)</span><br><span class="line">  .headers(headers)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></li></ul><h3 id="Virtual-host-虚拟主机"><a href="#Virtual-host-虚拟主机" class="headerlink" title="Virtual host 虚拟主机"></a>Virtual host 虚拟主机</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>虚拟地址，用于进行逻辑隔离，最上层的消息路由。</p><p>一个vhost里面可以有若干个exchange和queue。</p><p>同一个vhost里面不能有相同名称的exchange和queue。</p><h3 id="RabbitMQ架构图"><a href="#RabbitMQ架构图" class="headerlink" title="RabbitMQ架构图"></a>RabbitMQ架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200224135456.png" alt></p><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><h4 id="生产端的可靠性投递"><a href="#生产端的可靠性投递" class="headerlink" title="生产端的可靠性投递"></a>生产端的可靠性投递</h4><ul><li>保障消息的成功发出</li><li>保障MQ节点成功接收</li><li>发送端收到MQ节点确认应答</li><li>完善的消息补偿机制</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li><p>消息落库，对消息状态进行打标</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200225130507.png" alt></p><ol><li>业务数据入库，消息入库，消息状态为0</li><li>发送消息到MQ</li><li>消息确认回调</li><li>更新消息状态为1</li><li>定时任务拉取一段时间内状态一直为0的消息，进行重发</li><li>超过规定的重发次数仍然没有成功，更新消息状态为2，人工介入</li></ol></li><li><p>消息的延迟投递，做二次确认，回调检查（高并发）</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20200225133905.png" alt></p><ol><li>业务数据入库</li><li>发送两条消息，其中一条正常发送（队列0），其中一条延迟发送（队列1）</li><li>消费者消费消息</li><li>消费者发送消费确认消息到MQ（队列2）</li><li>callback服务消费确认消息（队列2），并将确认结果入库</li><li>callback服务消费延迟发送的消息（队列1），确认此消息是否成功，如果未成功，通知生产者重发</li></ol></li></ul><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><h4 id="消费端-幂等性保障"><a href="#消费端-幂等性保障" class="headerlink" title="消费端-幂等性保障"></a>消费端-幂等性保障</h4><p>消费端实现幂等性，就意味着我们的消息永远不会消费多次，即使我们收到了多条一样的消息</p><h4 id="幂等性解决方案"><a href="#幂等性解决方案" class="headerlink" title="幂等性解决方案"></a>幂等性解决方案</h4><ol><li>唯一ID+指纹码机制 ，利用数据库主键去重<ul><li>select count(1) from TABLE where id = 唯一id+指纹码</li><li>好处：实现简单；坏处：高并发下有数据库写入的性能瓶颈</li><li>解决方案：根据ID进行分库分表</li></ul></li><li>利用Redis的原子性去实现<ul><li>需要考虑的问题<ul><li>是否要进行数据的落库，如果要落库的话，要解决的问题是数据库和缓存如何做到原子性</li><li>如果不进行落库，都存储到缓存中，如何设置定时同步的策略</li></ul></li></ul></li></ol><h3 id="确认机制"><a href="#确认机制" class="headerlink" title="确认机制"></a>确认机制</h3><h4 id="Confirm确认消息"><a href="#Confirm确认消息" class="headerlink" title="Confirm确认消息"></a>Confirm确认消息</h4><h5 id="生产端代码"><a href="#生产端代码" class="headerlink" title="生产端代码"></a>生产端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定我们的消息投递模式: 消息的确认模式 </span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//添加一个确认监听</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">"-------no ack!-----------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">"-------ack!-----------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Return消息"><a href="#Return消息" class="headerlink" title="Return消息"></a>Return消息</h4><p>在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key找不到，这个时候如果我们需要监听这种不可达的消息，就要使用Return Listener</p><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><p>Mandatory:如果为true,则监听器会接收到路由不可达的消息，然后进行后续处理，如果为false,那么broker端自动删除该消息</p><h5 id="生产端代码-1"><a href="#生产端代码-1" class="headerlink" title="生产端代码"></a>生产端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">String routingKey, BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">System.err.println(<span class="string">"---------handle  return----------"</span>);</span><br><span class="line">System.err.println(<span class="string">"replyCode: "</span> + replyCode);</span><br><span class="line">System.err.println(<span class="string">"replyText: "</span> + replyText);</span><br><span class="line">System.err.println(<span class="string">"exchange: "</span> + exchange);</span><br><span class="line">System.err.println(<span class="string">"routingKey: "</span> + routingKey);</span><br><span class="line">System.err.println(<span class="string">"properties: "</span> + properties);</span><br><span class="line">System.err.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//mandatory设置为true</span></span><br><span class="line">channel.basicPublish(exchange, routingKeyError, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br></pre></td></tr></table></figure><h3 id="消费端自定义监听"><a href="#消费端自定义监听" class="headerlink" title="消费端自定义监听"></a>消费端自定义监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">"ip"</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">String exchangeName = <span class="string">"test_consumer_exchange"</span>;</span><br><span class="line">String routingKey = <span class="string">"consumer.#"</span>;</span><br><span class="line">String queueName = <span class="string">"test_consumer_queue"</span>;</span><br><span class="line"></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"-----------consume message----------"</span>);</span><br><span class="line">System.err.println(<span class="string">"consumerTag: "</span> + consumerTag);</span><br><span class="line">System.err.println(<span class="string">"envelope: "</span> + envelope);</span><br><span class="line">System.err.println(<span class="string">"properties: "</span> + properties);</span><br><span class="line">System.err.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h3><p>RabbitMQ提供了一种qos（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于consume或者channel设置qos的值）未被确认前，不进行消费新的消息</p><p><strong>autoACK</strong>  一定要设置成false.不自动签收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;</span></span><br><span class="line"><span class="comment">//prefetchSize：0</span></span><br><span class="line"><span class="comment">//prefetchCount：告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack,则该cousumer将block掉，直到有消息ack</span></span><br><span class="line"><span class="comment">//global:是否将上面设置应用于channel,就是上面的限制是channel级别还是consumer级别</span></span><br><span class="line"><span class="comment">//prefetchSize、global  RabbitMQ还没有实现</span></span><br><span class="line"><span class="comment">//1 限流方式  第一件事就是 autoAck设置为 false</span></span><br><span class="line"><span class="comment">//消费端</span></span><br><span class="line">channel.basicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Channel channel ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(channel);</span><br><span class="line"><span class="keyword">this</span>.channel = channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"-----------consume message----------"</span>);</span><br><span class="line">System.err.println(<span class="string">"consumerTag: "</span> + consumerTag);</span><br><span class="line">System.err.println(<span class="string">"envelope: "</span> + envelope);</span><br><span class="line">System.err.println(<span class="string">"properties: "</span> + properties);</span><br><span class="line">System.err.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    <span class="comment">//手动ack</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费端ack与重回队列"><a href="#消费端ack与重回队列" class="headerlink" title="消费端ack与重回队列"></a>消费端ack与重回队列</h3><h4 id="重回队列"><a href="#重回队列" class="headerlink" title="重回队列"></a>重回队列</h4><p>对没有处理成功的消息，把消息重新传递给Broker</p><p>一般在实际的应用中，都会关闭重回队列，设置为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Channel channel ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(channel);</span><br><span class="line"><span class="keyword">this</span>.channel = channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"-----------consume message----------"</span>);</span><br><span class="line">System.err.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((Integer)properties.getHeaders().get(<span class="string">"num"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//nack,处理失败，重回队列</span></span><br><span class="line">channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死信队列（DLX-Dead-Letter-Exchange）"><a href="#死信队列（DLX-Dead-Letter-Exchange）" class="headerlink" title="死信队列（DLX  Dead-Letter-Exchange）"></a>死信队列（DLX  Dead-Letter-Exchange）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另外一个Exchange,这个Exchange就是DLX</li><li>DLX也是一个正常的Exchange</li></ul><h4 id="消息变成死信的几种情况"><a href="#消息变成死信的几种情况" class="headerlink" title="消息变成死信的几种情况"></a>消息变成死信的几种情况</h4><ul><li>消息被拒绝（basic.reject/basic.nack）并且requeue=false</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">"ip"</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是一个普通的交换机 和 队列 以及路由</span></span><br><span class="line">String exchangeName = <span class="string">"test_dlx_exchange"</span>;</span><br><span class="line">String routingKey = <span class="string">"dlx.#"</span>;</span><br><span class="line">String queueName = <span class="string">"test_dlx_queue"</span>;</span><br><span class="line"></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; agruments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">agruments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dlx.exchange"</span>);</span><br><span class="line"><span class="comment">//这个agruments属性，要设置到声明队列上</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, agruments);</span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要进行死信队列的声明:</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"dlx.exchange"</span>, <span class="string">"topic"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"dlx.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"dlx.queue"</span>, <span class="string">"dlx.exchange"</span>, <span class="string">"#"</span>);</span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装并启动&quot;&gt;&lt;a href=&quot;#安装并启动&quot; class=&quot;headerlink&quot; title=&quot;安装并启动&quot;&gt;&lt;/a&gt;安装并启动&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置yum源&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[rabbitmq-erlang]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name=rabbitmq-erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gpgcheck=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repo_gpgcheck=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enabled=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="消息队列" scheme="https://haominglfs.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>多线程笔记</title>
    <link href="https://haominglfs.github.io/2020/01/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://haominglfs.github.io/2020/01/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-08T03:24:01.000Z</published>
    <updated>2020-04-06T03:18:41.843Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>CAS底层汇编命令  lock cmpxchg</p></li><li><p>volatile</p><ul><li><p>线程内存可见</p></li><li><p>防止指令重排序</p><a id="more"></a></li></ul></li><li><p>cache line 缓存行：当cpu去内存读数据时，会把附近的数据读出来，一般是64字节,是cpu同步的基本单位</p><p>缓存行隔离会比缓存行伪共享效率高</p></li><li><p>MESI</p><ul><li><p>伪共享</p></li><li><p>合并写</p><p>cpu内部的4个字节buffer</p></li><li><p>指令重排序</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;CAS底层汇编命令  lock cmpxchg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程内存可见&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;防止指令重排序&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>rsync使用笔记</title>
    <link href="https://haominglfs.github.io/2019/12/29/rsync%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://haominglfs.github.io/2019/12/29/rsync%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-28T16:27:30.000Z</published>
    <updated>2019-12-30T01:43:13.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rsync特征"><a href="#rsync特征" class="headerlink" title="rsync特征"></a>rsync特征</h3><ol><li><p>速度：第一次的rsync同步源的整个目录到目标位置。之后，rsync只传递改变的块或字节到目标位置，传输非常快。</p></li><li><p>安全：rsync在传输中允许使用ssh协议加密数据。</p></li><li><p>更少的带宽：rsync分别在发送和接收端对数据进行压缩和解压缩。</p></li><li><p>特权：不需要特殊权限来安装和执行rsync。</p><a id="more"></a></li></ol><h3 id="rsync语法"><a href="#rsync语法" class="headerlink" title="rsync语法"></a>rsync语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync options <span class="built_in">source</span> destination</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">source</span>和destination可以是本地或远程。在远程的情况下，需要指定登录名、远程服务器的名称和位置。</span></span><br></pre></td></tr></table></figure><h3 id="rsync使用示例"><a href="#rsync使用示例" class="headerlink" title="rsync使用示例"></a>rsync使用示例</h3><ol><li><p><strong>在本地服务器上同步两个目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -zvr 源目录 目标目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -z 允许压缩</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v  详细输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r  递归</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rsync 不会同步源文件或目录的时间戳</span></span><br></pre></td></tr></table></figure></li><li><p><strong>用rsync –a同步时间戳</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -azv 源目录 目标目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只同步一个文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -v /var/test.txt /root/temp/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将本地文件同步到远程服务器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz 源目录  username@remote_server_ip:path</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将远程文件同步到本地服务器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz username@remote_server_ip:path 目标目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指定使用某一协议同步</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz -e ssh username@remote_server_ip:path 目标目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不覆盖目标位置已改变的文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果目标位置的文件已被修改，而我们不希望旧文件覆盖它时,可以使用-u选项。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rsync -avzu username@remote_server_ip:path /root/temp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看rsync进度</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz --progress username@remote_server_ip:path /root/temp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除目标位置创建的文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">若我们希望rsync时删除在源位置不存在而在目标位置存在的文件，可以使用-delete选项。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz --delete username@remote_server_ip:path /root/temp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在目标位置不创建新文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-existing选项使得在同步时只同步目标位置存在的文件，而不创建新文件。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rsync -avz --existing username@remote_server_ip:path /root/temp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看源和目标的不同文件或目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rsync -avzi username@remote_server_ip:path /root/temp/</span></span><br><span class="line">receiving file list ... done</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">f.st.... Basenames</span></span><br><span class="line">.f....og. Dirnames</span><br><span class="line">=====================================</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 代表文件已被传输到本地主机。</span></span><br><span class="line">f：代表这是个文件</span><br><span class="line">s：代表文件大小发生变化</span><br><span class="line">t：代表时间戳发生变化</span><br><span class="line">o：属主发生变化</span><br><span class="line">g：属组发生变化</span><br></pre></td></tr></table></figure></li><li><p><strong>在传输时指定包括或排除某些文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --include 'P*' --exclude '*' username@remote_server_ip:path /root/temp</span><br></pre></td></tr></table></figure></li><li><p><strong>不传输大文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用rsync –max-size选项后，rsync将不传输大于指定大小的文件</span></span><br><span class="line">rsync -avz --max-size='100K' username@remote_server_ip:path /root/temp/</span><br></pre></td></tr></table></figure></li><li><p><strong>传输整个文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rsync的主要特征之一是它只传输改变的块到目标位置，而不是传输整个文件。如果网络带宽对你不是问题(CPU有)，您可以使用-w选项来传输整个文件。它会加速rsync过程，因为它不用在源和目标位置执行校验和。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rsync -avzW  username@remote_server_ip:path /root/temp</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;rsync特征&quot;&gt;&lt;a href=&quot;#rsync特征&quot; class=&quot;headerlink&quot; title=&quot;rsync特征&quot;&gt;&lt;/a&gt;rsync特征&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;速度：第一次的rsync同步源的整个目录到目标位置。之后，rsync只传递改变的块或字节到目标位置，传输非常快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安全：rsync在传输中允许使用ssh协议加密数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更少的带宽：rsync分别在发送和接收端对数据进行压缩和解压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特权：不需要特殊权限来安装和执行rsync。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>zookeeper学习笔记</title>
    <link href="https://haominglfs.github.io/2019/12/03/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://haominglfs.github.io/2019/12/03/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-03T09:36:27.000Z</published>
    <updated>2020-02-26T08:53:10.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ol><li><p>启动  ./zkServer.sh start</p></li><li><p>客户端连接 ./zkCli.sh</p><a id="more"></a></li></ol><h3 id="客户端命令学习"><a href="#客户端命令学习" class="headerlink" title="客户端命令学习"></a>客户端命令学习</h3><ul><li><p>ls /</p></li><li><p>ls2 /</p></li><li><p>stat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid = 0x0   #id</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970 #创建时间</span><br><span class="line">mZxid = 0x0   #修改id</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970  #修改时间</span><br><span class="line">pZxid = 0x6   #子节点id</span><br><span class="line">cversion = 2  #子节点版本</span><br><span class="line">dataVersion = 0 #当前节点数据版本号</span><br><span class="line">aclVersion = 0   #当前节点权限的版本号</span><br><span class="line">ephemeralOwner = 0x0 #是否是临时节点</span><br><span class="line">dataLength = 0   #数据长度</span><br><span class="line">numChildren = 2  #子节点数量</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>session过期，则临时节点znode会被抛弃</p></li><li><p>create命令</p></li><li><p>set命令</p></li><li><p>delete命令</p></li></ol><h3 id="watcher-机制"><a href="#watcher-机制" class="headerlink" title="watcher 机制"></a>watcher 机制</h3><h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><ul><li>针对每个节点的操作，都会有一个监督者-&gt;watcher</li><li>当监控的某个对象(znode)发生变化,则触发watcher事件</li><li>zk中的watcher是一次性的，触发后立即销毁</li></ul><h4 id="watcher事件类型1"><a href="#watcher事件类型1" class="headerlink" title="watcher事件类型1"></a>watcher事件类型1</h4><ul><li>创建父节点触发：NodeCreated</li><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li></ul><h4 id="watcher事件类型2"><a href="#watcher事件类型2" class="headerlink" title="watcher事件类型2"></a>watcher事件类型2</h4><ul><li>ls为父节点设置watcher,创建子节点触发：NodeChildrenChanged</li><li>ls为父节点设置watcher,删除子节点触发：NodeChildrenChanged</li><li>ls为父节点设置watcher,修改子节点不触发事件</li></ul><h3 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>针对节点设置相关读写权限，目的是为了保证数据安全</p><h4 id="acl命令"><a href="#acl命令" class="headerlink" title="acl命令"></a>acl命令</h4><ol><li>getAcl:获取某个节点的acl权限信息</li><li>setAcl:设置某个节点的acl权限信息</li><li>addauth:输入认证授权信息，注册时输入明文密码(登录)，但在zk系统中，密码是以加密的形式存在的</li></ol><h4 id="acl构成"><a href="#acl构成" class="headerlink" title="acl构成"></a>acl构成</h4><ol><li><p>zk的acl通过<code>[scheme:id:permisions]</code>来构成权限列表</p><ul><li><code>scheme</code>:代表采用的某种权限机制<ul><li><code>world</code>:<code>world</code>下只有一个<code>id</code>,即只有一个用户，也就是<code>anyone</code>,组合写法<code>world:anyone[permissions]</code></li><li><code>auth</code>:代表认证登录，需要注册用户有权限就可以，形式为<code>auth:user:password:[permissions]</code></li><li><code>digest</code>:需要对密码加密才能访问，组合形式为：<code>digest:username:BASE64(SHA1(password))[permissions]</code></li><li><code>ip</code>:此时现在ip访问，比如：<code>ip:192.168.1.1:[permissions]</code></li><li><code>super</code>:代表超级管理员，拥有所有权限</li></ul></li></ul></li></ol><ul><li>Id:代表允许访问的用户<ul><li>permisions:权限组合字符串<ul><li>CREATE：创建子节点</li><li>READ：获取节点、子节点</li><li>WRITE：设置节点数据</li><li>DELETE：删除子节点</li><li>ADMIN：设置权限</li></ul></li></ul></li></ul><h3 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>zk可以通过它自身提供的简写命令来和服务器进行交互</li><li>需要使用到nc命令，安装 <code>yum install nc</code></li><li><code>echo [commond]  | nc [ip][port]</code></li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li><code>[stat]</code>:查看zk的状态信息，以及是否mode</li><li><code>[ruok]</code>:查看当前zkserver是否启动，返回imok</li><li><code>[dump]</code>:列出未经使用的会话和临时节点</li><li><code>[conf]</code>:查看服务器配置</li><li><code>[cons]</code>:连接到服务端的客户端信息</li><li><code>[envi]</code>:环境变量</li><li><code>[mntr]</code>:监控zk健康信息</li><li><code>[wchs]</code>:展示watch的信息</li><li><code>[wchc]</code>与<code>[wchp]</code> :session 与watch 及path 与watch 的信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动  ./zkServer.sh start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端连接 ./zkCli.sh&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="https://haominglfs.github.io/2019/10/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>https://haominglfs.github.io/2019/10/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</id>
    <published>2019-10-28T11:30:35.000Z</published>
    <updated>2019-10-28T14:35:00.598Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h3><p>浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028205224.png" alt></p><a id="more"></a><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器。</p><h3 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><ol><li><p>规则：控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p></li><li><h5 id="Expires："><a href="#Expires：" class="headerlink" title="Expires："></a>Expires：</h5><ul><li>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</li><li>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。</li></ul></li><li><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><ul><li>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：<ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul></li></ul></li><li><p>例子(google首页)</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028212828.png" alt></p><ul><li>HTTP响应报文中expires的时间值，是一个绝对值</li><li>HTTP响应报文中Cache-Control为max-age=600，是相对值</li><li>由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在31536000秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</li><li>在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</li></ul></li><li><p>缓存存放位置</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028213435.png" alt></p><p>状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><ul><li><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p></li><li><p>过程如下</p><ul><li><p>访问<a href="https://haominglfs.github.io/">https://haominglfs.github.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028214728.png" alt></p></li><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://haominglfs.github.io/">https://haominglfs.github.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028214920.png" alt></p></li><li><p>刷新</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028215117.png" alt></p></li></ul></li><li><p>内存缓存(from memory cache)和硬盘缓存(from disk cache)的特点：</p><ul><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：<ul><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li></ul></li><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li><li>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</li></ul></li></ul></li><li></li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><ol><li><p>规则：控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，<strong>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</strong>。</p></li><li><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h5><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028215828.png" alt></p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028220214.png" alt></p></li><li><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h5><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028220406.png" alt></p></li></ol><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028220619.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/20191028220900.png" alt></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p><strong>为什么要有Etag</strong></p><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现（也就是说，ETag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul></li><li><p><strong>强缓存与协商缓存的区别可以用下表来表示：</strong></p><p>| 缓存类型 | 获取资源形式 |      状态码       |         发送请求到服务器         |<br>| :——: | :———-: | :—————: | :——————————: |<br>|  强缓存  |   从缓存取   |  200(from cache)  |         否，直接从缓存取         |<br>| 协商缓存 |   从缓存取   | 304(not Modified) | 是，通过服务器来告知缓存是否可用 |</p></li><li><p><strong>用户行为对缓存的影响</strong></p><p>|    用户操作     | Expires/Cache-Control | Last-Modifed/Etag |<br>| :————-: | :——————-: | :—————: |<br>|   地址栏回车    |         有效          |       有效        |<br>|  页面链接跳转   |         有效          |       有效        |<br>|    新开窗口     |         有效          |       有效        |<br>|    前进回退     |         有效          |       有效        |<br>|     F5刷新      |         无效          |       有效        |<br>| Ctrl+F5强制刷新 |         无效          |       无效        |</p><p><strong><em>F5 会 跳过强缓存规则，直接走协商缓存；Ctrl+F5 ，跳过所有缓存规则，和第一次请求一样，重新获取资源。</em></strong></p></li><li><p><strong>no-cache</strong></p><p>如果request headers中，Cache-Control为no-cache。表示不管服务端有没有设置Cache-Control，都必须从重新去获取请求。</p></li><li><p><strong>max-age=0</strong></p><p>max-age=0表示不管response怎么设置，在重新获取资源之前，先检验ETag/Last-Modified</p></li><li><p>不管是max-age=0还是no-cache，都会返回304（资源无修改的情况下），<strong>no-store才是真正的不进行缓存</strong>。</p></li><li><p><strong>Cache-Control与Expires</strong></p><p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p></li><li><p><strong>Last-Modified/ETag与Cache-Control/Expires</strong></p><p>配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</p><p>Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。</p><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/" target="_blank" rel="noopener">https://heyingye.github.io/2018/04/16/彻底理解浏览器的缓存机制/</a></p><p><a href="https://juejin.im/post/5c417993f265da61285a6075" target="_blank" rel="noopener">https://juejin.im/post/5c417993f265da61285a6075</a></p><p><a href="https://www.zhoulujun.cn/html/theory/network/2018_0306_8078.html" target="_blank" rel="noopener">https://www.zhoulujun.cn/html/theory/network/2018_0306_8078.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缓存过程&quot;&gt;&lt;a href=&quot;#缓存过程&quot; class=&quot;headerlink&quot; title=&quot;缓存过程&quot;&gt;&lt;/a&gt;缓存过程&lt;/h3&gt;&lt;p&gt;浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/haominglfs/images/20191028205224.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="浏览器" scheme="https://haominglfs.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://haominglfs.github.io/2019/10/23/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://haominglfs.github.io/2019/10/23/SQL%E4%BC%98%E5%8C%96/</id>
    <published>2019-10-23T15:12:48.000Z</published>
    <updated>2020-04-06T03:19:07.574Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li><p>3层Btree可以存放上百万条数据</p></li><li><p>Btree一般指的是B+树，数据全部存放在叶子节点中。</p></li><li><p>B+树中查询任意的数据次数：n次（B+树的高度）</p><a id="more"></a></li></ol><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ol><li>单值索引    单列的索引，一个表可以有多个单值索引</li><li>唯一索引    不能重复    可以为null</li><li>符合索引    多个列构成的索引</li><li>主键索引    不能重复，不能为null</li></ol><h4 id="SQL性能问题"><a href="#SQL性能问题" class="headerlink" title="SQL性能问题"></a>SQL性能问题</h4><ol><li>分析sql的执行计划（explain）,可以模拟SQL优化器执行sql语句</li><li>Mysql查询优化会干扰我们的优化。</li></ol><h4 id="explain-参数解析："><a href="#explain-参数解析：" class="headerlink" title="explain 参数解析："></a>explain 参数解析：</h4><ol><li><p>id:编号  </p><ul><li><p>id值相同，从上往下顺序执行;</p></li><li><p>id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)</p></li></ul></li><li><p>select_type 查询类型</p><ul><li><p>PRIMARY:包含子查询SQL中的 主查询 （最外层）</p></li><li><p>SUBQUERY：包含子查询SQL中的 子查询 （非最外层）</p></li><li><p>simple:简单查询（不包含子查询、union）</p></li><li><p>derived:衍生查询(使用到了临时表)</p><ul><li><p>在from子查询中只有一张表</p><blockquote><p>explain select  cr.cname     from ( select * from course where tid in (1,2) ) cr ;</p></blockquote></li><li><p>在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union</p><blockquote><p>explain select  cr.cname     from ( select <em> from course where tid = 1  union select </em> from course where tid = 2 ) cr ;</p></blockquote></li></ul></li></ul></li><li><p>table</p></li><li><p>partitions  </p></li><li><p>type  类型（索引类型）</p><ul><li>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all  其中：system,const只是理想情况；实际能达到 ref&gt;range</li><li>system（忽略）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询</li><li>const:仅仅能查到一条数据的SQL ,用于Primary key 或unique索引  （类型 与索引类型有关）</li><li>eq_ref:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）;常见于唯一索引 和主键索引</li><li>非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）</li></ul></li><li><p>possible_keys  预测用到的索引</p></li><li><p>key   实际使用的索引</p></li><li><p>key_len   实际使用的索引的长度</p></li><li><p>ref    表之间的引用</p></li><li><p>rows  通过索引查询到的数据量</p></li><li><p>filtered </p></li><li><p>Extra  额外的信息</p></li></ol><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li>聚集索引：页节点包含了完整的数据记录。（innoDB的主键索引）</li><li>非聚集索引  （myISAM的主键索引）</li></ol><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ol><li><p>为什么InnoDB表必须有主键，并且推荐使用整形的自增主键。</p><p>InnoDB的索引和数据存在同一个<code>表名.ibd</code>文件中</p><p>自增：可以减少B+树的分裂。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;3层Btree可以存放上百万条数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Btree一般指的是B+树，数据全部存放在叶子节点中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B+树中查询任意的数据次数：n次（B+树的高度）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>springboot学习1</title>
    <link href="https://haominglfs.github.io/2019/10/08/springboot%E5%AD%A6%E4%B9%A01/"/>
    <id>https://haominglfs.github.io/2019/10/08/springboot%E5%AD%A6%E4%B9%A01/</id>
    <published>2019-10-08T08:23:21.000Z</published>
    <updated>2019-10-08T08:24:24.490Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="springboot" scheme="https://haominglfs.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>macosX挂载NFS</title>
    <link href="https://haominglfs.github.io/2019/09/30/macosX%E6%8C%82%E8%BD%BDNFS/"/>
    <id>https://haominglfs.github.io/2019/09/30/macosX%E6%8C%82%E8%BD%BDNFS/</id>
    <published>2019-09-30T12:09:14.000Z</published>
    <updated>2019-10-03T10:08:03.326Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Mac OS X使用automounter，也称为 autofs 来挂载NFS输出卷。Autofs包含以下程序和daemons:</p><ul><li><p><strong>autofsd</strong></p><p>autofsd 执行 automount 之后 ，就会等待网络配置修改事件以及类似的事件发生。如果发生这样的事件，重新运行一次 automount 来更新挂载以反映当前automounter映射。也可以使用automount_reread 来运行 automount 。</p></li><li><p><strong>automountd</strong></p><p>automountd 是一个响应从 autofs 发出的请求的服务，用来挂载或卸载网络文件系统，并且提供目录的内容，基于automounter映射的内容。这个 automountd 是通过 launchd 来启动的。</p></li><li><p><strong>automount</strong></p><p>automount 是实际的挂载管理器。使用一些映射文件和配置文件来管理挂载和卸载远程资源。这些配置文件使用 /etc/autofs.conf 和 /etc/auto_master。</p></li><li><p><strong>automount_reread</strong></p><p>automount_reread 可以触发针对 autofs 的网络变更事件。</p><a id="more"></a></li></ul></li><li><p>检查autofs相关服务</p><ul><li><p><code>ps -ef | grep auto | grep -v grep</code></p><blockquote><p>​    0    95     1   0 六12上午 ??         0:00.03 autofsd</p></blockquote><p>可以看到系统运行了一个autofsd</p></li><li><p>检查一个服务是否通过 launchd 启动</p><p><code>sudo launchctl list | grep -E &#39;automo|autof&#39;</code></p><blockquote><p>95    0    com.apple.autofsd<br>13290    0    com.apple.automountd</p></blockquote></li></ul></li><li><p>Autofs映射，autofs 有两种映射方式</p><ul><li><p><strong>Direct Map</strong> </p><p>直接映射是直接列出目录的文件系统位置，关键字是完整的目录名字，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local      eng4:/export/local</span><br><span class="line">/src            eng4:/export/src</span><br></pre></td></tr></table></figure></li><li><p><strong>Indirect Map</strong></p><p>非直接映射是为了用于将大量的对象和一个单一目录关联的情况。每个映射入口是一个目录入口的简化名字。一个非常好的案例是 auto_home 映射，可以检测所有在 /home 目录下的入口,例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bill    argon:/export/home/bill</span><br><span class="line">brent   depot:/export/home/brent</span><br><span class="line">guy     depot:/export/home/guy</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="4"><li><p>创建AutoFS的Indirect Map</p><ul><li><p>先在Windows主机（win7）上设置共享目录Mac。</p></li><li><p>编辑 /etc/auto_master配置文件添加如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Automounter master map</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">+auto_master# Use directory service</span><br><span class="line">/net-hosts-nobrowse,hidefromfinder,nosuid</span><br><span class="line">/homeauto_home-nobrowse,hidefromfinder</span><br><span class="line">/Network/Servers-fstab</span><br><span class="line">/--static</span><br><span class="line">/Users/haominglfs/win7      autofs_win7</span><br></pre></td></tr></table></figure><p>以上配置告知 OS X 任何位于 <code>/Users/haominglfs/win7</code> 目录下的入口都通过 <code>/etc/autofs_win7</code>配置文件来配置。</p><blockquote><p>在auto_master前面的”+”符号表示让OS X查看目录服务（例如Open Directory，LDAP等等）是否有自动挂载记录，如果从目录服务找到自动挂载记录就使用其进行挂载。</p></blockquote><blockquote><p>/home目录被设置成 auto_home ，但是这个并不是一个完全目录，而是指 /etc/auto_home。这是一个非直接映射(indirect map)的例子。定义本地目录的挂载点，而远程挂载则是 /etc/auto_home 映射文件定义。网络用户登录将使用 /etc/auto_home 中定义的目录挂载到 /home 上。</p></blockquote><blockquote><p>同样在 /etc/auto_home 配置文件中也可以看到 +auto_home 的配置表示查找使用目录服务的auto_home记录。</p></blockquote></li><li><p>编辑 <code>/etc/autofs_win7</code>内容如下</p><p><code>mac -fstype=nfs 192.168.1.242:/e/mac</code></p></li><li><p>执行命令<code>showmount -e 192.168.1.242</code>  查看可挂载的NFS目录。</p></li><li><p>执行 automount 命令挂载</p><p><code>sudo automount -vc</code></p></li></ul></li></ol><p>​     </p><p>​     </p><p>​     </p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Mac OS X使用automounter，也称为 autofs 来挂载NFS输出卷。Autofs包含以下程序和daemons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;autofsd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;autofsd 执行 automount 之后 ，就会等待网络配置修改事件以及类似的事件发生。如果发生这样的事件，重新运行一次 automount 来更新挂载以反映当前automounter映射。也可以使用automount_reread 来运行 automount 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;automountd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;automountd 是一个响应从 autofs 发出的请求的服务，用来挂载或卸载网络文件系统，并且提供目录的内容，基于automounter映射的内容。这个 automountd 是通过 launchd 来启动的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;automount&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;automount 是实际的挂载管理器。使用一些映射文件和配置文件来管理挂载和卸载远程资源。这些配置文件使用 /etc/autofs.conf 和 /etc/auto_master。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;automount_reread&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;automount_reread 可以触发针对 autofs 的网络变更事件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nfs" scheme="https://haominglfs.github.io/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>cec邮件调用示例</title>
    <link href="https://haominglfs.github.io/2019/09/30/cec%E9%82%AE%E4%BB%B6%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>https://haominglfs.github.io/2019/09/30/cec%E9%82%AE%E4%BB%B6%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/</id>
    <published>2019-09-30T07:26:07.000Z</published>
    <updated>2019-10-03T10:53:56.739Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>调用邮件的服务为一个定时任务，定时扫描指定文件，若存在待发送的邮件，则以javaMail的方式调用邮件服务，调用示例如下(发件人邮箱SMTP服务器地址：mail.cec.com.cn)：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * JavaMail 版本: 1.6.0</span></span><br><span class="line"><span class="comment">    * JDK 版本: JDK 1.7 以上（必须）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sendMailService</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> myEmailAccount      发件人邮箱账号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> myEmailPassword     发件人邮箱密码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> myEmailSMTPHost     发件人邮箱SMTP服务器地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mainSendNameAccounts  收件人主送名称及账号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> copySendNameAccounts   收件人抄送名称及账号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> secretSendNameAccounts 收件人暗送名称及账号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> sendMsg      发送邮件主体信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendMail</span><span class="params">(String myEmailAccount, String myEmailPassword,String senderName,String myEmailSMTPHost,Map&lt;String, String&gt; mainSendNameAccounts,Map&lt;String, String&gt; copySendNameAccounts,Map&lt;String, String&gt; secretSendNameAccounts,Map sendMsg)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();                    <span class="comment">// 参数配置</span></span><br><span class="line">            props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);   <span class="comment">// 使用的协议（JavaMail规范要求）</span></span><br><span class="line">            props.setProperty(<span class="string">"mail.smtp.host"</span>, myEmailSMTPHost);   <span class="comment">// 发件人的邮箱的 SMTP 服务器地址</span></span><br><span class="line">            props.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"false"</span>);            <span class="comment">// 需要请求认证</span></span><br><span class="line">            <span class="comment">// 2. 根据配置创建会话对象, 用于和邮件服务器交互</span></span><br><span class="line">            Session session = Session.getInstance(props);</span><br><span class="line">            session.setDebug(<span class="keyword">true</span>); <span class="comment">//开启日志</span></span><br><span class="line">    <span class="comment">// 3. 创建一封邮件</span></span><br><span class="line">            MimeMessage message;</span><br><span class="line">    message = createMimeMessage(session, myEmailAccount, senderName,mainSendNameAccounts,copySendNameAccounts,secretSendNameAccounts,sendMsg);</span><br><span class="line">    <span class="comment">// 4. 根据 Session 获取邮件传输对象</span></span><br><span class="line">            Transport transport = session.getTransport();</span><br><span class="line">            <span class="comment">// 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错</span></span><br><span class="line">            transport.connect(myEmailAccount, myEmailPassword);</span><br><span class="line">            <span class="comment">// 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class="line">            transport.sendMessage(message, message.getAllRecipients());</span><br><span class="line">            transport.close();</span><br><span class="line">            <span class="keyword">return</span> Action.SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 创建邮件(带附件)</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> myEmailAccount     发件人账号</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> mainSendAccount    主送人员账号</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> copySendAccount    抄送人员账号</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> secretSendAccount  暗送人员账号</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> sendMsg            发送信息主体 </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MimeMessage <span class="title">createMimeMessage</span><span class="params">(Session session, String myEmailAccount,String senderName, Map&lt;String, String&gt; mainSendNameAccounts ,Map&lt;String, String&gt; copySendNameAccounts,Map&lt;String, String&gt; secretSendNameAccounts,Map sendMsg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       IUser sUser = WebBaseUtil.getCurrentUser();</span><br><span class="line">       String subject = (String)sendMsg.get(<span class="string">"subject"</span>);</span><br><span class="line">       String content = (String)sendMsg.get(<span class="string">"content"</span>);</span><br><span class="line">       String attachPath = (String)sendMsg.get(<span class="string">"attachPath"</span>);</span><br><span class="line">      </span><br><span class="line">           <span class="comment">// 1. 创建一封邮件</span></span><br><span class="line">           MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">           <span class="comment">// 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称）</span></span><br><span class="line">           message.setFrom(<span class="keyword">new</span> InternetAddress(myEmailAccount,senderName, <span class="string">"UTF-8"</span>));</span><br><span class="line">           <span class="comment">// 3. To: 收件人（可以增加多个收件人、抄送、密送）</span></span><br><span class="line">           <span class="comment">//设置主送人员</span></span><br><span class="line">           Set mainSendNameSet = mainSendNameAccounts.keySet();<span class="comment">//主送人员姓名</span></span><br><span class="line">           List mailSendList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">           <span class="keyword">for</span> (Object mainSendName : mainSendNameSet) &#123;</span><br><span class="line">           mailSendList.add(<span class="keyword">new</span> InternetAddress(mainSendNameAccounts.get(mainSendName)));</span><br><span class="line">   &#125;</span><br><span class="line">           InternetAddress[] mainAddress =(InternetAddress[])mailSendList.toArray(<span class="keyword">new</span> InternetAddress[mailSendList.size()]);</span><br><span class="line">           message.setRecipients(MimeMessage.RecipientType.TO,mainAddress);<span class="comment">//当邮件有多个收件人时，用逗号隔开</span></span><br><span class="line">           <span class="comment">//设置抄送人员</span></span><br><span class="line">           <span class="keyword">if</span>(!copySendNameAccounts.isEmpty())&#123;</span><br><span class="line">           Set copySendNameSet = copySendNameAccounts.keySet();<span class="comment">//主送人员姓名</span></span><br><span class="line">           List copylist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">           <span class="keyword">for</span> (Object copySendName : copySendNameSet) &#123;</span><br><span class="line">           copylist.add(<span class="keyword">new</span> InternetAddress(copySendNameAccounts.get(copySendName)));</span><br><span class="line">   &#125;</span><br><span class="line">           InternetAddress[] copyAddress =(InternetAddress[])copylist.toArray(<span class="keyword">new</span> InternetAddress[copylist.size()]);</span><br><span class="line">           message.setRecipients(MimeMessage.RecipientType.CC,copyAddress);<span class="comment">//当邮件有多个收件人时，用逗号隔开</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//设置暗送人员</span></span><br><span class="line">           <span class="keyword">if</span>(!secretSendNameAccounts.isEmpty())&#123;</span><br><span class="line">            Set secretSendNameSet = secretSendNameAccounts.keySet();<span class="comment">//主送人员姓名</span></span><br><span class="line">                List secretlist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                <span class="keyword">for</span> (Object secretSendName : secretSendNameSet) &#123;</span><br><span class="line">                secretlist.add(<span class="keyword">new</span> InternetAddress(secretSendNameAccounts.get(secretSendName)));</span><br><span class="line">        &#125;</span><br><span class="line">                InternetAddress[] secretAddress =(InternetAddress[])secretlist.toArray(<span class="keyword">new</span> InternetAddress[secretlist.size()]);</span><br><span class="line">                message.setRecipients(MimeMessage.RecipientType.CC,secretAddress);<span class="comment">//当邮件有多个收件人时，用逗号隔开</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 4. Subject: 邮件主题（标题有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改标题）</span></span><br><span class="line">           message.setSubject(subject, <span class="string">"UTF-8"</span>);</span><br><span class="line">           <span class="comment">//5. 创建正文文本"节点"</span></span><br><span class="line">           MimeBodyPart text = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">           text.setContent(content,<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">           <span class="comment">// 6. 创建附件"节点"</span></span><br><span class="line">           MimeMultipart mm = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">           mm.addBodyPart(text);</span><br><span class="line">           <span class="keyword">if</span>(StringHelper.isNotEmpty(attachPath))&#123;</span><br><span class="line">           MimeBodyPart attachment = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">           DataHandler dh = <span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(attachPath));</span><br><span class="line">           attachment.setDataHandler(dh);</span><br><span class="line">           attachment.setFileName(MimeUtility.encodeText(dh.getName())); </span><br><span class="line">           mm.addBodyPart(attachment);     <span class="comment">// 如果有多个附件，可以创建多个多次添加</span></span><br><span class="line">           mm.setSubType(<span class="string">"mixed"</span>);         <span class="comment">// 混合关系</span></span><br><span class="line">           &#125;</span><br><span class="line">           message.setContent(mm);</span><br><span class="line">           <span class="comment">// 6. 设置发件时间</span></span><br><span class="line">           message.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line">           <span class="comment">// 7. 保存设置</span></span><br><span class="line">           message.saveChanges();</span><br><span class="line">           <span class="keyword">return</span> message;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用邮件的服务为一个定时任务，定时扫描指定文件，若存在待发送的邮件，则以javaMail的方式调用邮件服务，调用示例如下(发件人邮箱SMTP服务器地址：mail.cec.com.cn)：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="工作" scheme="https://haominglfs.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>windows7配置nfs</title>
    <link href="https://haominglfs.github.io/2019/09/30/windows7%E9%85%8D%E7%BD%AEnfs/"/>
    <id>https://haominglfs.github.io/2019/09/30/windows7%E9%85%8D%E7%BD%AEnfs/</id>
    <published>2019-09-30T03:21:03.000Z</published>
    <updated>2019-10-28T12:57:35.158Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装haneWIN NFS SERVER</p><p><a href="https://www.hanewin.net/index.html" target="_blank" rel="noopener">下载地址</a></p></li><li><p>打开nfs客户端，配置如下</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/nfs.PNG" alt></p><p>编辑要共享的目录后，重启服务器，列表中就会显示共享的服务器。如果不生效，则打开win7的服务管理器重启nfsd服务。</p><p><img src="https://cdn.jsdelivr.net/gh/haominglfs/images/services.PNG" alt></p></li><li><p>问题</p><ul><li>保存配置文件时显示没有权限保存文件，需要以管理员身份运行nfs客户端。如何打开win7的管理员账户，可以参考<a href="http://www.2016win10.com/w10/20399.html" target="_blank" rel="noopener">win7系统设置用户帐户为最高权限的操作方法</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装haneWIN NFS SERVER&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hanewin.net/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="nfs" scheme="https://haominglfs.github.io/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>cas单点登录</title>
    <link href="https://haominglfs.github.io/2019/09/26/cas%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://haominglfs.github.io/2019/09/26/cas%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2019-09-26T14:19:47.000Z</published>
    <updated>2020-04-13T03:27:22.643Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/02/mI6OSbnkdZJpjKH.png" alt></p><h4 id="cas登出源码解析"><a href="#cas登出源码解析" class="headerlink" title="cas登出源码解析"></a>cas登出源码解析</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/10/02/mI6OSbnkdZJpjKH.png&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;cas登出源码解析&quot;&gt;&lt;a href=&quot;#cas登出源码解析&quot; class=&quot;headerlink&quot; title=&quot;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js原型</title>
    <link href="https://haominglfs.github.io/2019/09/24/js%E5%8E%9F%E5%9E%8B/"/>
    <id>https://haominglfs.github.io/2019/09/24/js%E5%8E%9F%E5%9E%8B/</id>
    <published>2019-09-24T13:37:02.000Z</published>
    <updated>2019-09-26T14:24:18.153Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>obj这个对象本质上是被Object函数创建的，因此<code>obj.__proto__=== Object.prototype</code>。我们可以用一个图来表示。</p><p><img src="https://raw.githubusercontent.com/haominglfs/images/master/20190925203303.png" alt></p><p> 即，每个对象都有一个<code>__proto__</code>属性，指向创建该对象的函数的prototype。</p></li><li><p>自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的<code>__proto__</code>指向的就是Object.prototype。但是Object.prototype确实一个特例——它的<code>__proto__</code>指向的是null。</p><p><img src="https://raw.githubusercontent.com/haominglfs/images/master/20190925204029.png" alt></p></li><li><p>函数也是一种对象，函数是由<code>Function</code>，所以<code>Object.__proto__ === Function.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;obj这个对象本质上是被Object函数创建的，因此&lt;code&gt;obj.__proto__=== Object.prototype&lt;/code&gt;。我们可以用一个图来表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercon
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iframe问题总结</title>
    <link href="https://haominglfs.github.io/2019/09/11/iframe%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://haominglfs.github.io/2019/09/11/iframe%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-11T07:07:10.000Z</published>
    <updated>2019-09-12T15:26:21.463Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iframe内部内容被添加了-lt-pre-gt-标签"><a href="#iframe内部内容被添加了-lt-pre-gt-标签" class="headerlink" title="iframe内部内容被添加了&lt;pre&gt;标签"></a>iframe内部内容被添加了<code>&lt;pre&gt;</code>标签</h4><p>今天在解决iframe上传文件的跨域问题时，遇到一个奇怪的问题，后台返回的json数据，放到iframe中时，莫名加上了<code>&lt;pre&gt;</code>标签，通过查询，最后在stackoverflow上找到这么一段话</p><blockquote><p>Assuming that the user POST the request in a form setting the target to an iframe. The JSON response will be sent back to the user on his/her iframe with content type set as “text/html”. It is set as “text/html” instead of “application/json” because I want to avoid having a “pre” tag injected by the browser around the JSON response. Anyway, how does the user read that JSON response if the iframe and the parent window have different domain? There is going to be a cross domain policy issue.</p></blockquote><p>大概意思就是，在form表单提交的是后，返回的json数据会根据form表单设置的target属性放到对应的iframe中，将返回的头信息改成<code>text/html</code>而不是默认的<code>application/json</code>就能避免返回的数据被包裹在<code>&lt;pre&gt;</code>标签中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;iframe内部内容被添加了-lt-pre-gt-标签&quot;&gt;&lt;a href=&quot;#iframe内部内容被添加了-lt-pre-gt-标签&quot; class=&quot;headerlink&quot; title=&quot;iframe内部内容被添加了&amp;lt;pre&amp;gt;标签&quot;&gt;&lt;/a&gt;ifram
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>websocket使用总结</title>
    <link href="https://haominglfs.github.io/2019/09/05/websocket%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://haominglfs.github.io/2019/09/05/websocket%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-05T10:12:10.000Z</published>
    <updated>2019-10-03T10:56:58.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司门户系统有一个显示待办消息的需求，要求其他系统产生的待办消息要及时的在门户系统中展示，网上查找了解到有ajax轮询和websocket两种主要方式，为了及时性，最终选择了websocket方式。</p><a id="more"></a><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>一图胜千言</p><p><img src="https://raw.githubusercontent.com/haominglfs/images/master/20190905181723.png" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- websocket--&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> msgTypes = &#123;</span><br><span class="line">            <span class="number">1</span>:<span class="string">'db'</span>,</span><br><span class="line">            <span class="number">2</span>:<span class="string">'dy'</span>,</span><br><span class="line">            <span class="number">3</span>:<span class="string">'yj'</span>,</span><br><span class="line">            <span class="number">4</span>:<span class="string">'gwdb'</span></span><br><span class="line">        &#125;</span><br><span class="line">        userId = <span class="string">'&lt;ww:property value="#session.sUser.userId" /&gt;'</span>;</span><br><span class="line">        <span class="comment">//定义websocket</span></span><br><span class="line">        <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8888/msg/ws"</span>);</span><br><span class="line">        <span class="comment">//维持心跳</span></span><br><span class="line">        <span class="keyword">var</span> heartCheck = &#123;</span><br><span class="line">            timeout: <span class="number">19000</span>,<span class="comment">//19s</span></span><br><span class="line">            timeoutObj: <span class="literal">null</span>,</span><br><span class="line">            reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                clearInterval(<span class="keyword">this</span>.timeoutObj);</span><br><span class="line">                <span class="keyword">this</span>.start();</span><br><span class="line">            &#125;,</span><br><span class="line">            start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.timeoutObj = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ws.readyState==<span class="number">1</span>)&#123;</span><br><span class="line">                        ws.send(<span class="string">"HeartBeat"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.timeout)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//连接websocket</span></span><br><span class="line">        ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> msg = <span class="string">'userid='</span>+userId;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"open and send message："</span>+msg);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ws.send(msg);</span><br><span class="line">            heartCheck.start();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"get message:"</span>+evt.data);</span><br><span class="line">            heartCheck.reset();</span><br><span class="line">            <span class="keyword">if</span>(evt.data.startsWith(<span class="string">'您'</span>))&#123;<span class="comment">//提示消息</span></span><br><span class="line">                $(<span class="string">"#msg_tip"</span>).text(evt.data);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'显示tip'</span>)</span><br><span class="line">                $(<span class="string">"#msg_tip"</span>).fadeIn();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> typeId = <span class="string">'span#'</span>+msgTypes[evt.data.split(<span class="string">':'</span>)[<span class="number">0</span>]];</span><br><span class="line">                $(typeId).html(evt.data.split(<span class="string">':'</span>)[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>($navTab.getTab(<span class="string">'dirMsg'</span>)!= <span class="string">''</span>)&#123;</span><br><span class="line">                    <span class="keyword">debugger</span>;</span><br><span class="line">                    <span class="comment">//$navTab.refreshCurrentTabForm('dirMsg');</span></span><br><span class="line">                    $forms = $(<span class="string">"#dirMsg"</span>).find(<span class="string">'.table-form'</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;$forms.length;i++)&#123;</span><br><span class="line">                        $navTab.submitForm($forms[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"WebSocketClosed!"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//发生异常</span></span><br><span class="line">        ws.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"WebSocketError!"</span>);</span><br><span class="line">            ws = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ws)&#123;</span><br><span class="line">                ws=<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li><li><p>后端（tomcat8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.css.apps.msg.websocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: haoming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/5/8 11:22 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.css.apps.msg.constant.MsgType;</span><br><span class="line"><span class="keyword">import</span> com.css.db.query.QueryCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: haoming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/5/6 7:07 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(value = <span class="string">"/ws"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Log log = LogFactory.getLog(WsServlet.class);</span><br><span class="line">    <span class="comment">//设置Map,存放每个用户的连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,WsServlet&gt; webSocketSet = <span class="keyword">new</span> HashMap&lt;String,WsServlet&gt;();</span><br><span class="line">    <span class="comment">//浏览器与服务端的回话，浏览器每new一个WebSocket就创建一个session，关闭或刷新浏览器，session关闭</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="comment">//代表浏览器</span></span><br><span class="line">    <span class="keyword">private</span> String userid;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送消息接口</span></span><br><span class="line"><span class="comment">     * 外部可以进行调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sendMsg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String sendMsg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="keyword">this</span>.userid+<span class="string">"发送消息:"</span>+sendMsg);</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(sendMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        log.info(<span class="keyword">this</span>+<span class="string">"有新连接,session="</span>+session+<span class="string">";userid="</span>+userid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>.userid);</span><br><span class="line">        log.info(<span class="keyword">this</span>.userid+<span class="string">"；连接关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String info)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="keyword">this</span>.userid+<span class="string">"；来自客户端的消息:"</span> + info);</span><br><span class="line">        String msg = <span class="string">"服务端接收到了来自客户端的消息："</span>+info;</span><br><span class="line">        <span class="keyword">if</span>(info.contains(<span class="string">"userid"</span>))&#123;</span><br><span class="line">            <span class="keyword">this</span>.userid = info.split(<span class="string">"userid="</span>)[<span class="number">1</span>];</span><br><span class="line">            log.info(<span class="string">"this.userid="</span>+<span class="keyword">this</span>.userid);</span><br><span class="line">            webSocketSet.put(userid, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//发送初始待办数量</span></span><br><span class="line">            sendMsg(<span class="string">"1:"</span>+getMsgNum(userid, MsgType.DAIBAN));</span><br><span class="line">            sendMsg(<span class="string">"2:"</span>+getMsgNum(userid, MsgType.DAIYUE));</span><br><span class="line">            sendMsg(<span class="string">"3:"</span>+getMsgNum(userid, MsgType.YOUJIAN));</span><br><span class="line">            sendMsg(<span class="string">"4:"</span>+getMsgNum(userid, MsgType.GWDAIBAN));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="keyword">this</span>.userid+<span class="string">"；发生错误"</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getMsgNum</span><span class="params">(String userId,Integer msgType)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">""</span>;</span><br><span class="line">        sql = <span class="string">"select count(a.uuid) from Msg a where a.receiver =:userId "</span> +</span><br><span class="line">                <span class="string">"and a.msgType =:msgType and a.msgStatus = 1"</span>;</span><br><span class="line">        QueryCache qc = <span class="keyword">new</span> QueryCache(sql);</span><br><span class="line">        qc.setParameter(<span class="string">"userId"</span>,userId);</span><br><span class="line">            qc.setParameter(<span class="string">"msgType"</span>,msgType);</span><br><span class="line">        <span class="keyword">return</span> qc.uniqueResult().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结(问题)</p><ol><li><p>前端添加心跳机制防止连接超时断开，但发送心跳的时间网络上未找到具体的应该根据什么来设置？。</p></li><li><p>利用如下代码测试最大连接数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line">        websocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">websocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> wsUri = <span class="string">"ws://localhost:8888/msg/ws"</span>;</span><br><span class="line">        <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(wsUri);</span><br><span class="line">        ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            ws.send(<span class="string">"User connected"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e.data)</span><br><span class="line">        &#125;;</span><br><span class="line">        ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"User disconnected"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start &gt; n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现浏览器最大连接数达到200时，其他连接无法连上，修改tomcat的连接数等配置，会有小幅度增加，达到了256，但不理想?，tomcat配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"20"</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span> <span class="attr">acceptCount</span>=<span class="string">"300"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">enableLookups</span>=<span class="string">"false"</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;公司门户系统有一个显示待办消息的需求，要求其他系统产生的待办消息要及时的在门户系统中展示，网上查找了解到有ajax轮询和websocket两种主要方式，为了及时性，最终选择了websocket方式。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kindeditor跨域问题解决</title>
    <link href="https://haominglfs.github.io/2019/09/05/kindeditor%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://haominglfs.github.io/2019/09/05/kindeditor%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2019-09-05T09:38:25.000Z</published>
    <updated>2019-10-03T10:57:11.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>因为在A系统中需要嵌入B系统的页面，两个系统有相同的父域名，所以使用了iframe+domain的方式解决跨域问题，在A系统的页面中加入了<code>document.domain = &#39;exame.com.cn&#39;;</code>;但是在嵌入kindeditor富文本编辑器后，上传图片出现跨域问题。</p><a id="more"></a><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>通过分析kindeditor的图片上传代码，如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab2"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"kindeditor_upload_iframe_1567676701755"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"ke-upload-area ke-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">target</span>=<span class="string">"kindeditor_upload_iframe_1567676701755"</span> <span class="attr">action</span>=<span class="string">"/portal/kindeditor/uploadImg?dir=image"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ke-dialog-row"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">"width:60px;"</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"localUrl"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"ke-input-text"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">style</span>=<span class="string">"width:200px;"</span> <span class="attr">readonly</span>=<span class="string">"true"</span>&gt;</span> &amp;nbsp;<span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"ke-inline-block ke-upload-button"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ke-upload-area"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ke-button-common"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">class</span>=<span class="string">"ke-button-common ke-button"</span> <span class="attr">value</span>=<span class="string">"浏览..."</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">class</span>=<span class="string">"ke-upload-file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span> <span class="attr">style</span>=<span class="string">"width: 60px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"ke-upload-button"</span> <span class="attr">value</span>=<span class="string">"浏览..."</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传后的返回值会放入<code>iframe</code>中，所以只要在iframe中加入<code>document.domain = &#39;exame.com.cn&#39;;</code>就能解决跨域问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参照kindeditor包中的uplod_json.jsp，重新写了一个UploadImgServlet，最终代码如下</p><ul><li><p>前端代码(正常写，不需要特殊处理)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">editor = KindEditor.create(<span class="string">'textarea[rel="ehContentOnlyOne"]'</span>,&#123;</span><br><span class="line">resizeType : <span class="number">1</span>,</span><br><span class="line">allowPreviewEmoticons : <span class="literal">false</span>,</span><br><span class="line">allowImageUpload : <span class="literal">true</span>,<span class="comment">//上传图片框本地上传的功能，false为隐藏，默认为true</span></span><br><span class="line">      allowImageRemote : <span class="literal">false</span>,<span class="comment">//上传图片框网络图片的功能，false为隐藏，默认为true</span></span><br><span class="line">cssPath:[<span class="string">'cssui/main/editor.css'</span>],</span><br><span class="line">            filePostName: <span class="string">"uploadFile"</span>,</span><br><span class="line">            uploadJson : <span class="string">'/portal/kindeditor/uploadImg'</span>,<span class="comment">// 上传图片接口</span></span><br><span class="line">items : [</span><br><span class="line"><span class="string">'source'</span>,<span class="string">'preview'</span>,<span class="string">'code'</span>,<span class="string">'|'</span>,<span class="string">'fontname'</span>, <span class="string">'fontsize'</span>, <span class="string">'|'</span>, <span class="string">'forecolor'</span>, <span class="string">'hilitecolor'</span>, <span class="string">'bold'</span>, <span class="string">'italic'</span>, <span class="string">'underline'</span>,</span><br><span class="line"><span class="string">'removeformat'</span>, <span class="string">'|'</span>, <span class="string">'justifyleft'</span>, <span class="string">'justifycenter'</span>, <span class="string">'justifyright'</span>, <span class="string">'insertorderedlist'</span>,</span><br><span class="line"><span class="string">'insertunorderedlist'</span>, <span class="string">'|'</span>, <span class="string">'emoticons'</span>,<span class="string">'image'</span>, <span class="string">'link'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>后端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.css.bbs.bbs.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileUploadException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: haoming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/3 10:36 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadImgServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置Response响应的编码</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//文件保存目录路径</span></span><br><span class="line">        String savePath = request.getServletContext().getRealPath(<span class="string">"/"</span>) + <span class="string">"attached/"</span>;</span><br><span class="line">        <span class="comment">//文件保存目录URL</span></span><br><span class="line">        String saveUrl  = request.getContextPath() + <span class="string">"/attached/"</span>;</span><br><span class="line">        <span class="comment">//定义允许上传的文件扩展名</span></span><br><span class="line">        HashMap&lt;String, String&gt; extMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        extMap.put(<span class="string">"image"</span>, <span class="string">"gif,jpg,jpeg,png,bmp"</span>);</span><br><span class="line">        extMap.put(<span class="string">"flash"</span>, <span class="string">"swf,flv"</span>);</span><br><span class="line">        extMap.put(<span class="string">"media"</span>, <span class="string">"swf,flv,mp3,wav,wma,wmv,mid,avi,mpg,asf,rm,rmvb"</span>);</span><br><span class="line">        extMap.put(<span class="string">"file"</span>, <span class="string">"doc,docx,xls,xlsx,ppt,htm,html,txt,zip,rar,gz,bz2"</span>);</span><br><span class="line">        <span class="comment">//最大文件大小</span></span><br><span class="line">        <span class="keyword">long</span> maxSize = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ServletFileUpload.isMultipartContent(request))&#123;</span><br><span class="line">            out.println(getError(<span class="string">"请选择文件。"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查目录</span></span><br><span class="line">        File uploadDir = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="keyword">if</span>(!uploadDir.isDirectory())&#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查目录写权限</span></span><br><span class="line">        <span class="keyword">if</span>(!uploadDir.canWrite())&#123;</span><br><span class="line">            out.println(getError(<span class="string">"上传目录没有写权限。"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String dirName = request.getParameter(<span class="string">"dir"</span>);</span><br><span class="line">        <span class="keyword">if</span> (dirName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dirName = <span class="string">"image"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!extMap.containsKey(dirName))&#123;</span><br><span class="line">            out.println(getError(<span class="string">"目录名不正确。"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        savePath += dirName + <span class="string">"/"</span>;</span><br><span class="line">        saveUrl += dirName + <span class="string">"/"</span>;</span><br><span class="line">        File saveDirFile = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="keyword">if</span> (!saveDirFile.exists()) &#123;</span><br><span class="line">            saveDirFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        String ymd = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">        savePath += ymd + <span class="string">"/"</span>;</span><br><span class="line">        saveUrl += ymd + <span class="string">"/"</span>;</span><br><span class="line">        File dirFile = <span class="keyword">new</span> File(savePath);</span><br><span class="line">        <span class="keyword">if</span> (!dirFile.exists()) &#123;</span><br><span class="line">            dirFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">        upload.setHeaderEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        List items = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            items = upload.parseRequest(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">            out.println(getError(<span class="string">"上传文件失败。"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator itr = items.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">            FileItem item = (FileItem) itr.next();</span><br><span class="line">            String fileName = item.getName();</span><br><span class="line">            <span class="keyword">long</span> fileSize = item.getSize();</span><br><span class="line">            <span class="keyword">if</span> (!item.isFormField()) &#123;</span><br><span class="line">                <span class="comment">//检查文件大小</span></span><br><span class="line">                <span class="keyword">if</span> (item.getSize() &gt; maxSize) &#123;</span><br><span class="line">                    out.println(getError(<span class="string">"上传文件大小超过限制。"</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//检查扩展名</span></span><br><span class="line">                String fileExt = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">                <span class="keyword">if</span> (!Arrays.&lt;String&gt;asList(extMap.get(dirName).split(<span class="string">","</span>)).contains(fileExt)) &#123;</span><br><span class="line">                    out.println(getError(<span class="string">"上传文件扩展名是不允许的扩展名。\n只允许"</span> + extMap.get(dirName) + <span class="string">"格式。"</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">                String newFileName = df.format(<span class="keyword">new</span> Date()) + <span class="string">"_"</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>) + <span class="string">"."</span> + fileExt;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    File uploadedFile = <span class="keyword">new</span> File(savePath, newFileName);</span><br><span class="line">                    item.write(uploadedFile);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    out.println(getError(<span class="string">"上传文件失败。"</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                obj.put(<span class="string">"error"</span>, <span class="number">0</span>);</span><br><span class="line">                obj.put(<span class="string">"url"</span>, saveUrl + newFileName);</span><br><span class="line">              <span class="comment">//解决跨域问题</span></span><br><span class="line">                out.println(obj.toString()+<span class="string">"&lt;script&gt;document.domain='cec.com.cn';&lt;/script&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将writer对象中的内容输出</span></span><br><span class="line">        out.flush();</span><br><span class="line">        <span class="comment">//关闭writer对象</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getError</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        obj.put(<span class="string">"error"</span>, <span class="number">1</span>);</span><br><span class="line">        obj.put(<span class="string">"message"</span>, message);</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>uploadImg<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.css.bbs.bbs.action.UploadImgServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>uploadImg<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/kindeditor/uploadImg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h3&gt;&lt;p&gt;因为在A系统中需要嵌入B系统的页面，两个系统有相同的父域名，所以使用了iframe+domain的方式解决跨域问题，在A系统的页面中加入了&lt;code&gt;document.domain = &amp;#39;exame.com.cn&amp;#39;;&lt;/code&gt;;但是在嵌入kindeditor富文本编辑器后，上传图片出现跨域问题。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
