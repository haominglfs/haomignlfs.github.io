---
title: 设计模式-迭代器模式
date: 2018-10-05 17:19:49
tags: 设计模式
categories: java 
---

#### 定义

提供了一种方法，顺序访问一个集合中的各个元素，而又不暴露该对象的内部表示。

<!--more-->

#### 适用场景

* 访问一个集合对象的内容而无需暴露它的内部表示。
* 为遍历不同的集合结构提供一个统一的接口。

#### UML

![](http://ow83fnk93.bkt.clouddn.com/20181005173913.png)

* Iterator(抽象迭代器):它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如:用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。

* ConcreteIterator(具体迭代器):它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

* Aggregate(抽象聚合类):它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

* ConcreteAggregate(具体聚合类):它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

* 在迭代器模式结构图中，我们可以看到具体迭代器类和具体聚合类之间存在双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作。除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，我们还可以将迭代器类设计为聚合类的内部类，JDK中的迭代器类就是通过这种方法来实现的，如下AbstractList类代码片段所示:

  ```java
  package java.util;
  ......
  public abstract class AbstractList<E> extends AbstractCollection<E>
      ......
      private class Itr implements Iterator<E> {
          int cursor = 0;
  		...... 
      }
  ...... 
  } 	
  ```


#### 总结

* 优点
  1. 分离了集合对象的遍历行为
* 缺点
  1. 类的个数成对增加。
  2. 增加了程序的复杂性。