<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js高级程序设计-读书笔记2]]></title>
    <url>%2F2018%2F05%2F04%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[引用类型 Object类型 创建Object实例的方式有两种： 123456789var person = new Object(); person.name = "Nicholas"; person.age = 29; //字面量方式: var person = &#123; name : "Nicholas", age :29 &#125; 一般来说，可以使用点表示法来访问对象属性，但也可以使用[]来访问对象属性，应该将要访问的属性以字符串的形式放在[]中，[]方法的主要优点是可以通过变量来访问属性。 Array类型 创建方式： 1234567891011121314151617181920212223 var colors = new Array(); var colors = new Array(20); var colors = new Array("red","blue","green"); var colors = new Array(3);//创建一个包含三项的数组 var colors = new Array("Greg");//创建包含"Greg"一项的数组 var colors = Array();//new 可以省略 var colors = []; var colors = ["red","blue","green"] var colors = ["red","blue",]//不要这样，这样会创建一个包含两个或三个的数组 var colors = [,,,,,] //不要这样，这样会创建一个包含五个或六个的数组 var colors = ["red","blue","green"];colors.length = 2;alert(colors[2]) ; //undefined var colors = ["red","blue","green"];colors.length = 4;alert(colors[3]); //undefined //利用length可以很方便的在数组末尾添加新项:var colors = ["red","blue","green"];colors[colors.length] = "black";colors[colors.length] = "brown"; 数组的每一项都可以保存任何类型的数据。 检测数组: 123if(value instanceof Array)&#123; //对数组执行某些操作&#125; instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入数组，那么传入的数组与第二个框架原生创建的数组分别具有各自不同的构造函数，要解决这个问题，es5新增了Array.isArray()方法，这个方法的目的是最终确定某个值到底是不是数组，而不管他是在哪个全局执行环境中创建的。 123456789101112131415161718192021222324252627if(Array.isArray(value))&#123; //对数组执行某些操作&#125;``` 5. 转换方法 所有对象都具有toLocalString()、toString()、valueOf()方法。调用数组的toString()方法会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的toString()方法。如果数组中的某一项的值是null、undefined,那么该值在join()、toLocalString()、toString()、valueOf()返回的结果中以空字符串表示。6. 栈方法 1. push()可以接收任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后数组的长度 2. pop()方法从数组末尾移除最后一项，减少数组的length值，返回移除的项7. 队列方法 1. 由于push()是向数组末尾添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的方法是shift(),他能够移除数组中的第一个项并返回该项，同时将数组长度减一。结合shift()和push()方法，可以像使用队列一样使用数组。 2. unshift()与shift()用途相反，它可以在数组前端添加任意项并返回新数组的长度。因此，同时使用unshift()和pop()方法，可以从相反的方向来模拟队列 8. 排序 1. sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort方法比较的也是字符串，如下： ```js var values = [0,1,5,10,15] values.sort() alert(values) //0,1,10,15,5 2. sort()方法可以接收一个比较函数作为参数，以便我们指定那个值位于那个值得前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如何第一个参数应该位于第二个之后则返回一个正数。 12345678910111213141516function compare(v1,v2)&#123; if(v1 &lt; v2)&#123; return 1; &#125;else if(v1&gt;v2)&#123; return -1; &#125;else&#123; return 0; &#125;&#125;values.sort(compare); // 15,10,5,1,0//对于数值类型或者valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数function compare(v1,v2)&#123; return v1 - v2;&#125; 操作方法 concat()该方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会简单的添加到结果数组的末尾。例如： 1234var colors = ['red','green','blue'];var colors2 = colors.cancat('yellow',['black','brown']);alert(colors) //red,green,bluealert(colors2) //red,green,blue,yellow,black,brown slice()基于当前数组中的一个或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。slice()方法不会影响原始数组。 splice() 删除：可以删除任意数量的项，只需指定2个参数：要删除的第 一项的位置和要删除的项数 插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，一直任意多个项。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项不必与删除的项数相等。 123456789101112var colors = ['red','green','blue'];var removed = colors.splice(0,1);//删除第一项alert(colors) //green,bluealert(removed) //redremoved = colors.splice(1,0,'yellow','orange');//从位置1开始插入两项alert(colors) //green,yellow,orange,bluealert(removed) //返回的是一个空数组removed = colors.splice(1,1,'red','purple')alert(colors) //green,red,purple,orange,bluealert(removed) // yellow 位置方法: indexOf()从数组的开头开始向后查找 lastIndexOf()从数组的末尾开始向前查找 这两个方法都返回要查找的项在数组中的位置，在没有找到的情况下返回-1。在比较第一个参数和数组中的每一项时，会使用全等操作符 迭代方法：每个方法都接收两个参数：要在每一项上运行的函数和(可选的)运行该函数的作用域对象–影响this的值。传入这些方法的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。 every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true. filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中的每一项运行给定函数,没有返回值。 map():对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组。 some():对数组中的每一项运行给定函数,如果该函数对任一项返回true,则返回true。 1234var numbers = [1,2,3,4];var everyResult = numbers.every(function(item,index,array)&#123; return (item &gt;2)&#125;) 归并方法：这两个方法都接收两个参数：一个在每一项上调用的函数和(可选的)作为归并基础的初始值。传给reduce()和reduceRight()的函数接收四个参数：前一个值、当前值、项的索引和数组对象 reduce()迭代数组中的每一项，构建一个最终的返回值，从数组的第一项开始。 reduceRight()从数组的最后一项向前遍历。 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array()&#123; return prev+cur; &#125;); alert(sum) //15]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级程序设计-读书笔记]]></title>
    <url>%2F2018%2F04%2F30%2Fjs%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&lt;script&gt;标签 无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面中出现的先后顺序对他们依次进行解析。 在文档的&lt;head&gt;元素中包含所有javascript标签，意味着必须等到全部的javascript代码都被下载、解析和执行完成后，才能开始呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容），所以，一般都这样写： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=&lt;device-width&gt;, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这里放内容--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;example2.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; defer属性：脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。defer属性只适用于外部脚本文件。在下面的代码中，虽然&lt;script&gt;放在了文档&lt;head&gt;元素中，但其中包含的脚本将延迟到浏览器遇到&lt;/html&gt;标签后再执行。HTML5规范要求脚本按照他们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。在现实中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=&lt;device-width&gt;, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;example2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这里放内容--&gt;&lt;/body&gt;&lt;/html&gt; HTML5为&lt;script&gt;元素定义了async属性。async属性告诉浏览器立即下载文件，但并不保证按照他们的先后顺序执行。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=&lt;device-width&gt;, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;example2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这里放内容--&gt;&lt;/body&gt;&lt;/html&gt; 在以上代码中，第二个脚本可能会在第一个脚本之前执行，因此，确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。 数据类型 五种基本数据类型：Undefined、Null、Boolean、Number、String;一种复杂数据类型：Object。 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 12345var message;//这个变量声明之后默认取得了undefined值//下面这个变量并没有声明//var agealert(typeof message); //&quot;undefined&quot;alert(typeof age); //&quot;undefined&quot; 对未声明和未初始化的变量执行typeof操作符都返回了undifined值。 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下： 12345if(car != null)&#123; //对car执行某些操作&#125;//实际上，undefined的值是派生自null值的alert(null == undefined) //true NaN,即非数值(Not a Number)是一个特殊的数值，这个数值用来表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。任何数值除以0会返回NaN；任何涉及NaN的操作（NaN/10）都会返回NaN;NaN与任何值都不相等，包括NaN本身。 执行环境及作用域 执行环境(execution context)是javaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据宿主环境不同，执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-职责链模式]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义避免请求发送者与接收者 耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。 UML Handler(抽象处理者):它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者 的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象(如结构图 中的successor)，作为其对下家的引用。通过该引用，处理者可以连成一条链。 ConcreteHandler(具体处理者):它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是 否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者;在具体处理 者中可以访问链中下一个对象，以便请求的转发。 总结 职责链模式的主要优点如下: 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。 职责链模式的主要缺点如下: 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理;一个请求也可能因职责链没有被正确配置而得不到处理。 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。 适用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-装饰模式]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 UML Component(抽象构件):它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent(具体构件):它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责(方法)。 Decorator(抽象装饰类):它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator(具体装饰类):它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 总结 装饰模式的主要优点如下: 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 装饰模式的主要缺点如下: 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多 的系统资源，在一定程序上影响程序的性能。 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。 适用场景 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类:第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长;第二类是因 为类已定义为不能被继承(如Java语言中的final类)。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 UML Builder(抽象建造者):它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件;另一 类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ConcreteBuilder(具体建造者):它实现了Builder接口，实现各个部件的具体构造和装配方 法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 Product(产品角色):它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品 的内部表示并定义它的装配过程。 Director(指挥者):指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装 配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建 造者的类型，并实例化具体建造者对象(也可以通过配置文件和反射机制)，然后通过指挥 者类的构造函数或者Setter方法将该对象传入指挥者类中。 总结 建造者模式的主要优点如下: 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则” 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式的主要缺点如下: 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指 挥者类中，而不在建造者类和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-原型模式]]></title>
    <url>%2F2018%2F04%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。 UML Prototype(抽象原型类):它是声明克隆方法的接口，是所有具体原型类的公共父类，可以 是抽象类也可以是接口，甚至还可以是具体实现类。 ConcretePrototype(具体原型类):它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 Client(客户类):让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直 接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体 原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 总结 原型模式的主要优点如下: (1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 (2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 (3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的 工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的 克隆方法实现的，无须专门的工厂类来创建产品。 (4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起 来，以便在需要的时候使用(如恢复到某一历史状态)，可辅助实现撤销操作。 原型模式的主要缺点如下: (1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进 行改造时，需要修改源代码，违背了“开闭原则”。 (2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 适用场景(1) 创建新对象成本较大(如初始化需要占用较长的时间，占用太多的CPU资源或网络资 源)，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对 其成员变量稍作修改。(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java读书笔记]]></title>
    <url>%2F2017%2F09%2F27%2Feffective-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第52条：通过接口引用对象如果有合适的接口类型存在，那么对于参数、返回值、变量和成员变量来说，就都应该使用接口类型进行声明；如果你养成了用接口作为类型的习惯，你的程序将会更加灵活，当你决定更换实现时，所要做的就只是构造器中类的名称。有一点值得注意：如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么新的实现也要提供相同的功能。类实现了接口，但是提供了接口中不存在的额外的方法–例如LinkedHashMap。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活；如果不是，则使用类层次结构中提供了必要功能的最基础的类。 第38条：检查参数的有效性每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制，应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制 第43条：返回0长度的数组或者集合，而不是Null返回类型为数组或集合的方法没理由返回null，应该返回一个零长度的数组或者集合。可以做成在每当需要返回空集合时，都返回同一个不可变的空集合。Collections.emptySet、emptyList、emptyMap提供的正是这种集合。public List&lt;Person&gt; getPersons(){ if(persons.isEmpty()){ return Collections.emptyList(); }else{ return persons; } } 第46条：for-each循环优先于传统的for循环for-each在简洁性和预防bug方面有着传统的for循环无法比拟的优势，并且没有性能损失，应该尽可能的使用for-each循环。有三种常见的情况无法使用for-each循环: 过滤:如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法。 转换：如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。 平行迭代：如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。第48条：如果需要精确的答案，请避免使用float和double第49条：基本类型优先于装箱基本类型基本类型和装箱基本类型之间有三个主要的区别： 基本类型只有值，而装箱基本类型则具有与它们的值不同的地址。换句话说，两个装箱基本类型可以具有相同的值和不同的地址。 基本类型只有功能完备的值，而每个装箱基本类型除了它对应的基本类型的所有功能值外，还有个非功能值：null 基本类型通常比装箱基本类型更节省时间和空间. 1234567public static void main(String[] args)&#123; Long sum = 0L; for(long i=0;i&lt;Integer.MAX_VALUE;i++)&#123; sum += i; &#125; System.out.println(sum);&#125; 这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量(sum)声明为装箱基本类型Long,而不是基本类型long,变量被反复的装箱和拆箱，导致明显的性能下降。总之，当可以选择的时候，基本类型要优先于装箱基本类型。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>effective-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-适配器模式]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义将一个接口转换成客户希望的另一个接口，使接口不兼容的哪些类可以一起工作，其别名为包装器（Wrapper）。 UML根据适配器类与适配者类的关系不同，适配器模式可分为对象 适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系;在类适配 器模式中，适配器与适配者之间是继承(或实现)关系。在实际开发中，对象适配器的使用 频率更高,对象适配器结构如下: Target(目标抽象类):目标抽象类定义客户所需接口，可以是一个抽象类或接口也可以是具体类。 Adapter(适配器类):适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个 Adaptee对象使二者产生联系。 Adaptee(适配者类):适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可 能没有适配者类的源代码。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法模式]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义与简单工厂模式不同，在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。 UML Product(抽象产品):它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ProductA(具体产品):它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory(抽象工厂):在抽象工厂类中，声明了工厂方法（FactoryMethod)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 FactoryA(具体工厂):它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 总结工厂方法模式的主要优点如下: 用户只需要关心所需产品对应的工厂，不需要关心创建细节。 系统中加入新产品时，无需修改抽象工厂和抽象产品类，只需要添加具体的产品类和工厂类，符合开闭原则。 工厂方法模式的主要缺点如下: 增加产品时，需要创建具体的产品类和具体的工厂类，增加了系统的复杂度。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习笔记]]></title>
    <url>%2F2017%2F06%2F17%2Fjvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[java虚拟机与程序的生命周期在如下几种情况下，java虚拟机将结束生命周期： 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致java虚拟机进程结束 类的加载、链接与初始化 加载:查找并加载类的二进制数据，就是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口 链接: 验证：确保被加载的类的正确性 准备:为类的静态变量分配内存，并将其初始化为默认值 解析:把类中的符号引用转变为直接引用 初始化：为类的静态变量赋予正确的初始值 java程序对类的使用方式分为两种: 主动使用(六种): 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射(如 Class.forName(“info.haominglfs.test”)) 初始化一个类的子类 java虚拟机启动时被表明为启动类的类(含有main方法) 被动使用，除了以上六种情况，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化 所有的java虚拟机实现必须在每个类或接口被java程序首次主动使用时才初始化他们，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化 加载.class文件的方式: 从本地系统中直接加载 通过网络下载.class文件 从zip,jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将java原文件动态编译为.class文件]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-简单工厂模式]]></title>
    <url>%2F2017%2F06%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义简单工厂模式:定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法模式。 UML Prodcut(抽象产品角色)：它是所有工厂类所创建的所有对象的父类，封装了各种产品对象的共有方法。 ProductA(具体产品角色)：它是简单工厂模式的创建目标，继承了抽象产品角色。 Factory(工厂角色）：简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑，可以被外界直接调用，提供了静态工厂方法。 简单工厂模式的简化有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中。 总结 简单工厂模式的主要优点如下:(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可， 对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类， 在一定程度上提高了系统的灵活性。 简单工厂模式的主要缺点如下(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受 到影响(2) 使用简单工厂模式势必会增加系统中类的个数(引入了新的工厂类)，增加了系统的复杂 度和理解难度。(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成 工厂逻辑过于复杂，不利于系统的扩展和维护。(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 试用场景(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太 过复杂(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2017%2F06%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在实际开发中，为了节约系统资源，有时需要确保系统中某个类只有唯一的一个实例，当这个唯一的实例创建成功后，我们无法再创建一个同类型的其他对象，所有的操作都基于这个唯一的对象，这就是单例模式的动机所在。类图如下：为了实现唯一性，该类有以下特性：1.将该类构造函数的可见性改为private。2.定义一个静态类型的Singtelon私有变量。3.增加一个共有的静态方法，用来获得该私有变量。 123456789101112class Singleton &#123; private Singleton()&#123;&#125; //私有的构造函数 private static Singleton instance = null;//私有静态变量 public Singleton getInstance()&#123; if(instance == null)&#123; return new Singleton(); &#125; return instance; &#125;&#125; 上面的代码在多线程环境下会出现创建多个实例的情况。对此，有两种解决方案：1.饿汉式单例模式 12345678class EagerSingleton &#123; private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; 2.懒汉式单例模式(使用双重检查锁) 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125; &#125; 需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 一种更好的实现方式Initialization Demand Holder (IoDH)技术： 123456789class Singleton &#123; private Singleton() &#123; &#125; private static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return HolderClass.instance; &#125;&#125; 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2017%2F04%2F30%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git使用今天写了一个在在标签页显示数字的chrome扩展程序，打算提交到github,顺便学习了将一个已有的项目提交到github的方法。 登录github，新建一个仓库 进入项目的本地目录，执行如下命令： git initgit remote add origin git@github.com:haominglfs/tab_number.git//与远程仓库建立关联git add .git commit -m &#39;tab_number extension of chrome v0.1&#39;git push -u origin master //push到远程仓库]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2]]></title>
    <url>%2F2017%2F04%2F19%2FiTerm2%2F</url>
    <content type="text"><![CDATA[#iTerm2配置 配色1.git clone git@github.com:altercation/solarized.git2.这里我们要使用的是iterm2-colors-solarized目录下的，包括Solarized Dark.itermcolors和Solarized Light.itermcolors两个配置文件。3.打开Preferences-&gt;Profiles-&gt;Color面板，在Color Presets中将以上 两个配置方案导入，然后选择Solarized Dark或者Solarized Light即可。一般推荐使用Solarized Dark，Solarized Light有种亮瞎的感觉。 oh-my-zsh1.接下来，用oh-my-zsh来武装zsh，一行命令搞定：sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;2.oh-my-zsh中提供了多套主题可供选择，有不同的输出样式及配色。默认应该是robbyrussell，感觉中规中矩没啥亮点。翻看了一下，发现了agnoster主题，感觉非常入眼。接下来，编辑~/.zshrc，找到变量ZSH_THEME将其赋值改为agnoster即可。3.为了显示正常，需要安装powerline字体，方法如下：git clone git@github.com:powerline/fonts.gitcd fonts./install然后，在iTerm2-&gt;Preferences-&gt;Profiles-&gt;Text面板中将Non-ASCII Font改成Roboto Mono Powerline，显示就正常了！]]></content>
      <categories>
        <category>iTerm2</category>
      </categories>
      <tags>
        <tag>iTerm2配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks配置]]></title>
    <url>%2F2017%2F04%2F19%2Fshadowsocks%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[#shadowsocks配置 第一步 用远程工具登录aws主机 第二步：安装shadowsocks依赖 sudo -s //获取超级管理员权限 apt-get update//更新apt-get apt-get install python-pip//安装pyton包管理工具 pip install shadowsocks//安装shadowsocks ssserver -c /etc/shadowsocks.json -d start//启动shadowsocks 第三步:配置shadowsocks vi /etc/shadowsocks.json//编辑配置文件 单一端口配置 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:端口, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;连接密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false &#125; 多端口配置 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;端口1&quot;: &quot;连接密码1&quot;, &quot;端口2&quot; : &quot;连接密码2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; 开启aws 入站端口 配置好shaodowsocks后，还需要将配置中的端口打开,这样客户端的服务才能链接得上EC2中的shadowsocks服务首先打开正在运行的实例，向右滚动表格，看到最后一项，安全组，点击进入 默认是开启了一个22端口（这是给ssh访问的），再建一个如下图红框标示的端口，我的shadowsocks配置的端口是8388，所以这里就开启8388， 配置文件编辑完成后，接下来就可以部署运行了： 1ssserver -c /etc/shadowsocks.json -d start 当然，我们可不希望每次重启服务器都手动启动 SS, 因此我们要把这条命令放到这个文件下：/etc/rc.d/rc.local，这样以后就能开机自动运行了。]]></content>
      <categories>
        <category>vpn</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
</search>
